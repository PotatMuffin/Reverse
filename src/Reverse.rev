0 = _iota long
4 = PROT_EXEC int
2 = PROT_WRITE int
1 = PROT_READ int
0 = PROT_NONE int
2 = MAP_PRIVATE int
32 = MAP_ANONYMOUS int

256  = S_IRUSR long
128  = S_IWUSR long
32   = S_IRGRP long
16   = S_IWGRP long
4    = S_IROTH long

512 = O_TRUNC  int
64  = O_CREAT  int
1   = O_WRONLY int
0   = O_RDONLY int

0 = LOG_INFO int
1 = LOG_WARN int
2 = LOG_ERROR int

0 = STDIN  int
1 = STDOUT int
2 = STDERR int

0(void*) = null void*
null(heapinfo_t*) = heap heapinfo_t* 

1 = true byte
0 = false byte

(false)iota = TT_EOF     short
(false)iota = TT_PLUS    short
(false)iota = TT_MIN     short
(false)iota = TT_STAR    short
(false)iota = TT_FSLASH  short
(false)iota = TT_PERCENT short
(false)iota = TT_INT     short
(false)iota = TT_NEWLINE short

(true)iota  = NODE_ROOT      short
(false)iota = NODE_BINOP     short
(false)iota = NODE_INT_LIT   short

Settings {
    source_fn byte*
    output_fn byte*
    memory    long
    debug     byte
} struct

(()get_argc, ()get_argv)main = exit_code int
(exit_code)exit

{
    [null(byte*), "out.asm", 16 << 20, 0] = settings Settings
    { 1 return } ((argc, argv, &settings)parse_args != 0) if

    [0(heapchunk_t*),0,0,null] = _heap heapinfo_t
    &_heap = heap

    {   
        (LOG_ERROR, "Could not initialize heap\n")log
        1 return
    } ((&_heap, memory::settings)init_heap != 0) if

    (0, O_RDONLY, source_fn::settings)open = source_fd int

    { 
        (LOG_ERROR, "Source file not found\n")log 
        1 return
    } (source_fd < 0) if

    null(Result*) = res Result*

    (source_fd)read_file = src byte*
    [source_fd, src, [source_fn::settings, 1, 1], 0] = lexer Lexer
    (&lexer)tokenize = res

    { (err::res)print_error; 1 return} (err::res != null) if
    res::res(List*) = tokens List*
    (heap, src)heap_free
    (heap, res(void*))heap_free

    [tokens, 0] = parser Parser
    (&parser, TT_EOF)parse = res

    { (err::res)print_error; 1 return} (err::res != null) if
    res::res(NodeRoot*) = ast NodeRoot*

    { (ast(Node*))display_ast } (debug::settings) if

    (heap, res(void*))heap_free

    (tokens)deconstruct_list
    (heap, tokens(void*))heap_free
    0 return
} (argc int, argv byte**) main int

{
    false = found_source byte
    false = found_output byte

    {
        (argv + i * @void*) = arg byte**

        {
            true = debug::settings
            continue
        } (("-d", *arg)strcmp) if else
        { 
            0 = num long
            arg + @void* = arg
            
            {
                (LOG_ERROR, "Invalid argument for -m\n")log
                1 return
            } ((*arg, &num)try_parse_int) if

            num << 10 = memory::settings
            i + 1 = i
            continue
        } ( ("-m", *arg)strcmp ) if

        {
            *arg = output_fn::settings
            true = found_output
            continue
        } (!found_output) if else  
        {
            *arg = source_fn::settings
            true = found_source
            continue
        } (!found_source) if

        (*argv)print_usage
        1 return

    } (i + 1 = i; i < argc; 1 = i int) for

    { (*argv)print_usage; 1 return } (!found_source) if

    0 return
} (argc int, argv byte**, settings Settings*) parse_args int

{
    ("Usage: ")print
    (prog)print
    (" <source> [output]\n")print
    ("optional settings:\n")print
    ("  -m <limit>   set the available memory in kilobytes\n")print
    ("  -d           show debug information")print
    return
} (prog byte*) print_usage void

Position {
    file byte*
    line int
    column int
} struct

Error {
    msg byte*
    pos Position
} struct

{
    (LOG_ERROR, "")log
    (STDERR, file::pos::err)fprint; (STDERR, ":")fprint
    (STDERR, line::pos::err)fprint_num; (STDERR, ":")fprint
    (STDERR, column::pos::err)fprint_num; (STDERR, ": ")fprint
    (STDERR, msg::err)fprint
    return
} (err Error*) print_error void

Result {
    err Error*
    res void*
} struct

{
    { 
        err::that = err::this
        (heap, that(void*))heap_free
        null return
    } (err::that != null) if

    null(Error*) = err::this
    (heap, that(void*))heap_free
    res::that(void*) return
} (this Result*, that Result*) result_register void*

{
    (heap, @Error)heap_alloc(Error*) = err Error*
    [file::pos, line::pos, column::pos] = pos::err
    msg = msg::err
    err = err::this
    this return
} (this Result*, pos Position*, msg byte*) result_fail Result*

{
    null(Error*) = err::this
    res = res::this
    this return
} (this Result*, res void*) result_success Result*

#####################################################################
# List
#####################################################################

List {
    count int
    capacity int
    items void**
} struct

{
    {
        (items::_list + i * @void*) = Pitem void**
        (heap, *Pitem)heap_free
    } (i + 1 = i; i < count::_list; 0 = i int) for
    (heap, items::_list(void*))heap_free
    return
} (_list List*) deconstruct_list void

{
    {
        capacity::_list*2 = capacity::_list
        (heap, items::_list(void*), capacity::_list * @void*)heap_realloc(void**) = buf void**
        buf = items::_list
    } (count::_list == capacity::_list) if

    (items::_list + count::_list * @void*) = pos void**
    item = *pos 
    count::_list + 1 = count::_list
    return
} (_list List*, item void*) list_append void

{
    0 = count::_list
    8 = capacity::_list
    (heap, 8 * @void*)heap_alloc(void**) = buf void**
    buf = items::_list
    return
} (_list List*) init_list void

#####################################################################
# Lexer
#####################################################################

Token {
    type short
    data long
    pos Position
} struct

{
    null(byte*) = str byte*
    { "newline" = str }   (type == TT_NEWLINE) if else
    { "int" = str }       (type == TT_INT)     if else
    { "'%'" = str }       (type == TT_PERCENT) if else
    { "'/'" = str }       (type == TT_FSLASH)  if else
    { "'*'" = str }       (type == TT_STAR)    if else
    { "'-'" = str }       (type == TT_MIN)     if else
    { "'+'" = str }       (type == TT_PLUS)    if
    str return
} (type short) tt_to_str byte*

{
    -1 = prec byte
    { 5 = prec }       (type == TT_PERCENT) if else
    { 5 = prec }       (type == TT_FSLASH)  if else
    { 5 = prec }       (type == TT_STAR)    if else
    { 4 = prec }       (type == TT_MIN)     if else
    { 4 = prec }       (type == TT_PLUS)    if
    prec return
} (type short) get_prec byte

Lexer {
    fd int
    src byte*
    pos Position
    index long
} struct

{
    *(src::lexer + index::lexer) = c byte
    index::lexer + 1 = index::lexer
    column::pos::lexer + 1 = column::pos::lexer
    {
        1 = column::pos::lexer
        line::pos::lexer + 1 = line::pos::lexer
    } (c == 10) if
    c return
} (lexer Lexer*) lexer_consume byte

{
    *(src::lexer + index::lexer + offset) = c byte
    c return
} (lexer Lexer*, offset int) lexer_peek byte

{
    (heap, @List)heap_alloc(List*) = tokens List*
    (tokens)init_list

    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Error*) = err::res
    null(Token*) = tok Token*
    {
        (lexer, 0)lexer_peek = c byte
        {
            (lexer)lexer_consume
            continue
        } (c == 9 || c == 11 || c == 12 || c == 13 || c == 32) if

        (heap, @Token)heap_alloc(Token*) = tok
        [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::tok
        0 = type::tok
        0 = data::tok

        { 
            0 = n int
            {
                n * 10 = n
                n + (c - '0') = n
                (lexer, 1)lexer_peek = c 
                { break } ('9' < c || c < '0') if
                (lexer)lexer_consume
            } (true) while

            TT_INT = type::tok
            n = data::tok
        } ('9' >= c && c >= '0') if else
        { TT_NEWLINE = type::tok } (c == 10 ) if else
        { TT_PERCENT = type::tok } (c == '%') if else
        { TT_FSLASH = type::tok }  (c == '/') if else
        { TT_STAR = type::tok }    (c == '*') if else
        { TT_MIN = type::tok }     (c == '-') if else 
        { TT_PLUS = type::tok }    (c == '+') if

        {
            (heap, @Error)heap_alloc(Error*) = err Error*
            "Illegal character\n" = msg::err
            [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::err
            err = err::res
            res return
        } (type::tok == 0) if 

        (tokens, tok(void*))list_append
        (lexer)lexer_consume
    } ((lexer, 0)lexer_peek) while 

    (heap, @Token)heap_alloc(Token*) = tok 
    [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::tok
    TT_EOF = type::tok
    (tokens, tok(void*))list_append

    (res, tokens(void*))result_success return
} (lexer Lexer*) tokenize Result*

#####################################################################
# Parser
#####################################################################

Node {
    type short
    pos  Position
} struct

NodeRoot {
    type     short
    pos      Position
    children List*
} struct

{
    (heap, @List)heap_alloc(List*) = children List*
    (heap, @NodeRoot)heap_alloc(NodeRoot*) = node NodeRoot*
    NODE_ROOT = type::node
    [file::pos, line::pos, column::pos] = pos::node
    (children)init_list
    children = children::node
    node return
} (pos Position*) create_node_root NodeRoot*

NodeBinop {
    type  short
    pos   Position
    left  void*
    op    short
    right void*
} struct

{
    (heap, @NodeBinop)heap_alloc(NodeBinop*) = node NodeBinop*
    NODE_BINOP = type::node
    [file::pos, line::pos, column::pos] = pos::node
    left = left::node
    op = op::node
    right = right::node
    node return
} (pos Position*, left void*, op short, right void*) create_node_binop NodeBinop*

NodeIntLit {
    type short
    pos  Position
    val  long
} struct

{
    (heap, @NodeIntLit)heap_alloc(NodeIntLit*) = node NodeIntLit*
    NODE_INT_LIT = type::node
    [file::pos, line::pos, column::pos] = pos::node
    val = val::node
    node return
} (pos Position*, val long) create_node_int_lit NodeIntLit*

Parser {
    tokens List*
    index long
} struct

{
    (items::tokens::parser + index::parser * @void*)(Token**) = Ptok Token**
    index::parser + 1 = index::parser
    *Ptok return
} (parser Parser*) parser_consume Token*

{
    (parser, 0)parser_peek = tok Token*
    { 
        (parser)parser_consume 
        tok return
    } (type::tok == type) if

    null(Token*) return
} (parser Parser*, type short) parser_consume_token Token*

{
    (parser, 0)parser_peek = tok Token*
    {  
        (parser)parser_consume
        (parser, 0)parser_peek = tok 
    } (type::tok == type) while
    return
} (parser Parser*, type short) parser_consume_all void

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Error*) = err::res
    (parser)parser_consume = tok Token*
    pos::tok = pos Position

    {
        (expected_type)tt_to_str = type byte*
        ("Expected ", type)strconcat = msg byte*
        (heap, msg(void*))heap_free
        (msg, "\n")strconcat = msg

        (res, &pos, msg)result_fail return
    } (type::tok != expected_type) if

    tok(void*) = res::res
    res return
} (parser Parser*, expected_type short) parser_expect Result*

{
    (items::tokens::parser + (index::parser + offset) * @void*)(Token**) = Ptok Token**
    *Ptok return
} (parser Parser*, offset int) parser_peek Token*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*
    pos::tok = pos Position
    (&pos)create_node_root = root NodeRoot*

    {
        (parser, TT_NEWLINE)parser_consume_all
        (parser, 0)parser_peek = tok 
        { break } ( type::tok == end ) if

        (res, (parser)parse_expr)result_register = node void*
        { res return } (err::res != null) if 

        (children::root, node)list_append

        (parser, 0)parser_peek = tok
        { break } ( type::tok == end ) if
    } (true) while

    (res, root(void*))result_success return
} (parser Parser*, end short) parse Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parse_bin_expr return

    (res, null)result_success return
} (parser Parser*) parse_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*

    (res, (parser)parse_atom)result_register = left void*
    { res return } (err::res != null) if 

    {

        (parser, 0)parser_peek = op Token*
        pos::op = pos Position

        (type::op)get_prec = prec byte
        # prec will be -1 if the token type is not an operator
        # therefore the prec of a non operator token type will always be lower than min_prec
        { break } (prec < min_prec) if  
        (parser)parser_consume

        (res, (parser, prec + 1)parse_bin_expr)result_register = right void*
        { res return } (err::res != null) if 

        (&pos, left, type::op, right)create_node_binop(void*) = left
    } (true) while

    (res, left)result_success return
} (parser Parser*, min_prec byte) parse_bin_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*
    pos::tok = pos Position
    null = node void*

    { (&pos, data::tok)create_node_int_lit(void*) = node } (type::tok == TT_INT) if
    (parser)parser_consume

    { 
        (res, &pos, "Expected int\n")result_fail return 
    } (node == null) if

    (res, node)result_success return
} (parser Parser*) parse_atom Result*

{
    {
        node(NodeIntLit*) = nodeIntLit NodeIntLit*
        (val::nodeIntLit)print_num
    } (type::node == NODE_INT_LIT) if else
    { 
        node(NodeBinop*) = nodeBinop NodeBinop*
        ("(")print 
        (left::nodeBinop(Node*))display_ast
        (op::nodeBinop)tt_to_str = type byte*
        (type)print
        (right::nodeBinop(Node*))display_ast
        (")")print 
    } (type::node == NODE_BINOP) if else
    { 
        node(NodeRoot*) = nodeRoot NodeRoot*
        {
            (items::children::(nodeRoot) + i * @void*)(Node**) = Pnode Node**
            *Pnode = _node Node*
            (_node)display_ast
            ("\n")print
        } (i + 1 = i; i < count::children::nodeRoot; 0 = i int) for
    } (type::node == NODE_ROOT) if
    return
} (node Node*) display_ast void

#####################################################################
# other
#####################################################################

{
    0 = argc long
    # argc is stored at [rsp + 24]
    # this is because the variable argc takes up 8 bytes
    # rbp gets pushed onto the stack at the start of a function taking up 8 bytes
    # and the return adress get pushed onto the stack when calling the function also taking up 8 bytes
    asm("mov rax, [rsp + 24]")
    asm("mov [rbp - 8], rax")
    argc return
} () get_argc long

{
    0(byte**) = argv byte**
    # the pointer to the first argument is stored at [rsp + 32]
    # because argc is stored at [rsp + 24], and takes up 8 bytes
    # see explanation in get_argc
    asm("lea rax, [rsp + 32]")
    asm("mov [rbp - 8], rax")
    argv return
} () get_argv byte**

{
    [0] = statbuf stat
    (&statbuf, fd)fstat
    st_size::statbuf = size long
    (heap, size+1)heap_alloc(byte*) = buf byte*
    (size + 1, buf, fd)read 
    buf return
} (fd int) read_file byte*

{
    STDOUT = fd int
    { STDERR = fd } (log_level == LOG_ERROR) if
    { (fd, "[ERROR] ")fprint } (log_level == LOG_ERROR) if else
    { (fd, "[WARN] ")fprint } (log_level == LOG_WARN) if else
    { (fd, "[INFO] ")fprint } (log_level == LOG_INFO) if
    (str)print
    return
} (log_level int, str byte*)log void

{
    (str)strlen = len long
    (len, str, 1)write
    return
} (str byte*) print void

{
    (str)strlen = len long
    (len, str, fd)write
    return
} (fd int, str byte*) fprint void

{
    (num)itoa = str byte*
    (str)print
    (heap, str(void*))heap_free
    return
} (num long) print_num void

{
    (num)itoa = str byte*
    (fd, str)fprint
    (heap, str(void*))heap_free
    return
} (fd int, num long) fprint_num void

{
    false = is_neg byte
    { -num = num; true = is_neg } (num < 0) if
    (num)log10l = log10 int
    (num >= (10, log10)pow) || num < 8 = x long
    log10 + x + is_neg = length int

    (heap, length + 1)heap_alloc(byte*) = str byte*
    0 = *(str + length)

    {
        { 0 = *(str + i); continue } (i == length) if

        num % 10 = digit byte
        num / 10 = num

        digit + '0' = digit
        digit = *(str + i)
    } (i - 1 = i; i >= 0; length = i int) for

    {'-' = *str } (is_neg) if
    str return
} (num long) itoa byte*

{   
    0 = len long
    { len + 1 = len } (*(str + len)) while
    len return
} (str byte*) strlen long

{
    (str1)strlen = str1len long
    (str2)strlen = str2len long
    { false return } (str1len != str2len) if
    true = is_equal byte

    {
        (*(str1 + i) == *(str2 + i)) = is_equal
        { break } (!is_equal) if
    } (i + 1 = i; i < str1len; 0 = i int) for

    is_equal return
} (str1 byte*, str2 byte*) strcmp byte

{
    (str1)strlen = str1len long
    (str2)strlen = str2len long
    (heap, str1len + str2len + 1)heap_alloc = str byte*

    0 = i int
    { *(str1 + i) = *(str + i) }         (i + 1 = i; i < str1len;i)         for
    { *(str2 + i-str1len) = *(str + i) } (i + 1 = i; i < str1len+str2len;i) for
    0 = *(str + i)
    str return
} (str1 byte*, str2 byte*) strconcat byte*

{
    (src)strlen = len long
    
    {
        *(src + i) = x byte
        x = *(dest + i)
        { break } (!x) if
    } (i + 1 = i; true; 0 = i long) for  
    return
} (src byte*, dest byte*) strcpy void

{
    (str)strlen = len long
    0 = *res

    {
        *res * 10 = *res
        *(str + i) = n long
        { break } (n == 0) if
        { 1 return } (n > '9' || n < '0') if

        n - '0' = n
        n + *res = *res
    } (i + 1 = i; i < len; 0 = i int) for

    0 return
} (str byte*, res long*) try_parse_int byte

{
    0 = y int 
    64 = n int
    x >> 32 = y; {n - 32 = n; y = x } (y != 0) if
    x >> 16 = y; {n - 16 = n; y = x } (y != 0) if
    x >> 8 = y; { n - 8 = n; y = x } (y != 0) if
    x >> 4 = y; { n - 4 = n; y = x } (y != 0) if
    x >> 2 = y; { n - 2 = n; y = x } (y != 0) if
    x >> 1 = y; { n - 2 return } (y != 0) if
    n - x return
} (x long) clzl long

{
    { 0 return } (x == 0) if
    63 - (x)clzl return
} (x long) log2l long

{
    (x)log2l / (10)log2l return
} (x long) log10l long

{
    x = n int
    { n * x = n } (i + 1 = i; i < pow; 1 = i int) for
    n return
} (x long, pow long) pow long

{
    _iota = n long
    { _iota + 1 = _iota } else { 0 = _iota } (reset) if
    n return
} (reset byte) iota long

#####################################################################
# syscalls
#####################################################################
stat {
    st_dev        long
    st_ino        long
    st_nlink      long
    st_mode       int
    st_uid        int
    st_gid        int
    __pad0        int
    st_rdev       long
    st_size       long
    st_blksize    long
    st_blocks     long
    st_atime      long
    st_atime_nsec long
    st_mtime      long
    st_mtime_nsec long
    st_ctime      long
    st_ctime_nsec long
    __unused1     long
    __unused2     long
    __unused3     long
} struct

{
    asm("mov rax, 0")
    asm("syscall")
    return
} (count long, buf byte*, fd int) read void

{
    asm("mov rax, 1")
    asm("syscall")
    return
} (count long, buf byte*, fd int) write void

{
    -1 = fd int
    asm("mov rax, 2")
    asm("syscall")
    asm("mov [rbp - 24], eax")
    fd return
} (mode long, flags int, fn byte*) open int

{
    asm("mov rax, 3")
    asm("syscall")
    return
} (fd int) close void

{
    asm("mov rax, 5")
    asm("syscall")
    return
} (statbuf stat*, fd int) fstat void

{   
    null = mem void* 
    asm("mov r10, rcx")
    asm("mov rax, 9")
    asm("syscall")
    asm("mov [rbp - 44], rax")
    mem return
} (offset long, fd int, flags int, prot int, len long, addr void*) mmap void*

{
    asm("mov rax, 60")
    asm("syscall")
    return
} (code long) exit void

#####################################################################
# malloc
#####################################################################

heapchunk_t {
    size long
    start void*
    inuse byte
} struct

heapinfo_t {
    chunks heapchunk_t*
    nchunks long
    chunks_cap long
    memory void*
} struct

{
    nchunks::heap = nchunks long

    ("========================================================================\n")print
    {
        (chunks::heap + i * @heapchunk_t) = Pchunk heapchunk_t*
        ("[")print; (i)print_num; ("] ")print
        ("start: ")print; (start::Pchunk(long))print_num
        (", ")print; ("size: ")print; (size::Pchunk)print_num
        (", ")print; ("inuse: ")print
        { ("false")print } else { ("true")print } (inuse::Pchunk) if
        ("\n")print

    } (i + 1 = i; i < nchunks; 0 = i int) for
    ("========================================================================\n")print

    return
} (heap heapinfo_t*) display_heap void

{       
    { 1 return } (size < 1024) if

    (0, -1, MAP_PRIVATE | MAP_ANONYMOUS, PROT_READ | PROT_WRITE, size, null) mmap = memory_start void*
    (0, -1, MAP_PRIVATE | MAP_ANONYMOUS, PROT_READ | PROT_WRITE, size, null) mmap(heapchunk_t*) = chunk_memory heapchunk_t*
    { 1 return } (memory_start < null) if
    { 1 return } (chunk_memory < null) if

    [size, memory_start, false] = chunk heapchunk_t

    chunk_memory = chunks::heap
    size / @heapchunk_t = chunks_cap::heap
    1 = nchunks::heap
    
    chunk = *(chunks::heap)

    0 return
} (heap heapinfo_t*, size long) init_heap int

{
    { 1 return } ( nchunks::heap + 1 == chunks_cap::heap) if

    {
        (chunks::heap + i * @heapchunk_t) = Pchunk heapchunk_t*
        *Pchunk = _chunk heapchunk_t
        (chunks::heap + (i + 1) * @heapchunk_t) = Pchunk
        _chunk = *Pchunk
    } (i - 1 = i; i >= index; nchunks::heap - 1 = i int) for

    (chunks::heap + index * @heapchunk_t) = Pchunk
    *chunk = *Pchunk

    nchunks::heap + 1 = nchunks::heap
    0 return
} (heap heapinfo_t*, chunk heapchunk_t*, index long) insert_chunk int

{
    {
        nchunks::heap - 1 = nchunks::heap
        return
    } (index == nchunks::heap - 1) if

    {
        (chunks::heap + (i + 1) * @heapchunk_t) = Pchunk heapchunk_t*
        *Pchunk = _chunk heapchunk_t

        (chunks::heap + i * @heapchunk_t) = Pchunk
        _chunk = *Pchunk
    } (i + 1 = i; i < (nchunks::heap - 1); index = i int) for

    nchunks::heap - 1 = nchunks::heap
    return
} (heap heapinfo_t*, index long) remove_chunk void

{
    (chunks::heap + chunk_index * @heapchunk_t) = chunk heapchunk_t*

    nchunks::heap = new_chunk_index long
    [bytes, start::chunk, false] = new_chunk heapchunk_t

    start::chunk + bytes = start::chunk
    size::chunk - bytes = size::chunk

    {
        null(heapchunk_t*) return
    } ((heap, &new_chunk, chunk_index)insert_chunk) if

    chunk return
} (chunk_index long, heap heapinfo_t*, bytes long) split_chunk heapchunk_t*

{ 
    nchunks::heap - 1 = chunk_index long

    {
        ((chunks::heap) + i * @heapchunk_t) = chunk heapchunk_t*

        { continue } (size::chunk < bytes) if
        { continue } (inuse::chunk) if

        { 
            (i, heap, bytes)split_chunk = chunk
        } (size::chunk > bytes) if

        true = inuse::chunk
        start::chunk return
    } (i - 1 = i; i >= 0; chunk_index = i int) for

    null return
} (heap heapinfo_t*, bytes long) heap_alloc void*

{
    {
        ((chunks::heap) + i * @heapchunk_t) = chunk heapchunk_t*

        { 
            i return 
        } (start::chunk == ptr) if

    } (i + 1 = i; i < nchunks::heap; 0 = i int) for

    -1 return
} (heap heapinfo_t*, ptr void*) find_chunk long

{
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*

    {
        ((chunks::heap) + (index + 1) * @heapchunk_t) = Rchunk heapchunk_t*

        { 
            size::Rchunk + size::chunk = size::chunk
            (heap, index + 1)remove_chunk
        } ( !inuse::Rchunk ) if

    } (index < nchunks::heap - 1) if

    {
        ((chunks::heap) + (index - 1) * @heapchunk_t) = Lchunk heapchunk_t*

        { 
            start::Lchunk = start::chunk
            size::chunk + size::Lchunk = size::chunk
            (heap, index - 1)remove_chunk
        } ( !inuse::Lchunk ) if

    } (index > 0) if

    return
} (heap heapinfo_t*, index long) merge_chunk void

{
    (heap, ptr)find_chunk = index long
    { return } ( index == -1 ) if
    
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*
    false = inuse::chunk
    (heap, index)merge_chunk

    return
} (heap heapinfo_t*, ptr void*) heap_free void

{
    (heap, buf)find_chunk = index long
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*
    (heap, new_size)heap_alloc = new_buf void*

    size::chunk = n long
    { new_size = n } (size::chunk > new_size) if
    0 = i int

    {
        *(buf(long*) + i) = *(new_buf(long*) + i)
    } (i + 8 = i; i < n && n > 8; i) for

    n - i = n

    { *(buf(int*) + i) = *(new_buf(int*) + i);     n - 4 = n } (n >= 4) if
    { *(buf(short*) + i) = *(new_buf(short*) + i); n - 2 = n } (n >= 2) if
    { *(buf(byte*) + i) = *(new_buf(byte*) + i);   n - 1 = n } (n >= 1) if

    (heap, buf)heap_free
    new_buf return
} (heap heapinfo_t*, buf void*, new_size long) heap_realloc void*