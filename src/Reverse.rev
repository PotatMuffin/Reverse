0 = _iota long
4 = PROT_EXEC int
2 = PROT_WRITE int
1 = PROT_READ int
0 = PROT_NONE int
2 = MAP_PRIVATE int
32 = MAP_ANONYMOUS int

256  = S_IRUSR long
128  = S_IWUSR long
32   = S_IRGRP long
16   = S_IWGRP long
4    = S_IROTH long

512 = O_TRUNC  int
64  = O_CREAT  int
1   = O_WRONLY int
0   = O_RDONLY int

0 = LOG_INFO int
1 = LOG_WARN int
2 = LOG_ERROR int

0 = STDIN  int
1 = STDOUT int
2 = STDERR int

0(void*) = null void*
null(heapinfo_t*) = heap heapinfo_t* 

1 = true byte
0 = false byte

(false)iota = TT_EOF     short
(false)iota = TT_PLUS    short
(false)iota = TT_MIN     short
(false)iota = TT_STAR    short
(false)iota = TT_FSLASH  short
(false)iota = TT_PERCENT short
(false)iota = TT_EQ      short
(false)iota = TT_INT     short
(false)iota = TT_PARENL  short
(false)iota = TT_PARENR  short
(false)iota = TT_BRACKL  short
(false)iota = TT_BRACKR  short
(false)iota = TT_IDENT   short
(false)iota = TT_KEYWORD short
(false)iota = TT_NEWLINE short
(true)iota  = TT_COUNT   short

(false)iota = NODE_ROOT       short
(false)iota = NODE_UNOP       short
(false)iota = NODE_BINOP      short
(false)iota = NODE_INT_LIT    short
(false)iota = NODE_VAR_DEF    short
(false)iota = NODE_VAR_ASSIGN short
(false)iota = NODE_VAR        short
(false)iota = NODE_IF         short
(false)iota = NODE_WHILE      short
(false)iota = NODE_FOR        short
(true)iota  = NODE_COUNT      short

(false)iota = IMMVALUE short
(false)iota = REG      short
(true)iota  = MEMPOS   short

(false)iota = BUILTIN short
(true)iota  = VAR short

"rax"  = _RAX byte*; "eax"  = _EAX byte*;  "ax"   = _AX byte*;   "al"   = _AL byte*
"rbx"  = _RBX byte*; "ebx"  = _EBX byte*;  "bx"   = _BX byte*;   "bl"   = _BL byte*
"rcx"  = _RCX byte*; "ecx"  = _ECX byte*;  "cx"   = _CX byte*;   "cl"   = _CL byte*
"rdx"  = _RDX byte*; "edx"  = _EDX byte*;  "dx"   = _DX byte*;   "dl"   = _DL byte*
"rsi"  = _RSI byte*; "esi"  = _ESI byte*;  "si"   = _SI byte*;   "sil"  = _SIL byte*
"rdi"  = _RDI byte*; "edi"  = _EDI byte*;  "di"   = _DI byte*;   "dil"  = _DIL byte*
"rsp"  = _RSP byte*; "esp"  = _ESP byte*;  "sp"   = _SP byte*;   "spl"  = _SPL byte*
"rbp"  = _RBP byte*; "ebp"  = _EBP byte*;  "bp"   = _BP byte*;   "bpl"  = _BPL byte*
"r8"   = _R8 byte*;  "r8d"  = _R8D byte*;  "r8w"  = _R8W byte*;  "r8b"  = _R8B byte*
"r9"   = _R9 byte*;  "r9d"  = _R9D byte*;  "r9w"  = _R9W byte*;  "r9b"  = _R9B byte*
"r10"  = _R10 byte*; "r10d" = _R10D byte*; "r10w" = _R10W byte*; "r10b" = _R10B byte*
"r11"  = _R11 byte*; "r11d" = _R11D byte*; "r11w" = _R11W byte*; "r11b" = _R11B byte*
"r12"  = _R12 byte*; "r12d" = _R12D byte*; "r12w" = _R12W byte*; "r12b" = _R12B byte*
"r13"  = _R13 byte*; "r13d" = _R13D byte*; "r13w" = _R13W byte*; "r13b" = _R13B byte*
"r14"  = _R14 byte*; "r14d" = _R14D byte*; "r14w" = _R14W byte*; "r14b" = _R14B byte*
"r15"  = _R15 byte*; "r15d" = _R15D byte*; "r15w" = _R15W byte*; "r15b" = _R15B byte*
&_RAX = regs byte**

"qword " = _QWORD byte*; "dword " = _DWORD byte*; "word " = _WORD byte*; "byte " = _BYTE byte*
&_QWORD = sizes byte**

0 = QWORD short
1 = DWORD short
2 = WORD  short
3 = BYTE  short

0  = RAX short
1  = RBX short
2  = RCX short
3  = RDX short
4  = RSI short
5  = RDI short
6  = RSP short
7  = RBP short
8  = R8  short
9  = R9  short
10 = R10 short
11 = R11 short
12 = R12 short
13 = R13 short
14 = R14 short
15 = R15 short

Settings {
    source_fn byte*
    output_fn byte*
    memory    long
    debug     byte
} struct

[null(byte*), "out.asm", 16 << 20, 0] = settings Settings
(()get_argc, ()get_argv)main = exit_code int
(exit_code)exit

{
    { 1 return } ((argc, argv, &settings)parse_args != 0) if

    [0(heapchunk_t*),0,0,null] = _heap heapinfo_t
    &_heap = heap

    {   
        (LOG_ERROR, "Could not initialize heap\n")log
        1 return
    } ((&_heap, memory::settings)init_heap != 0) if

    (0, O_RDONLY, source_fn::settings)open = source_fd int

    { 
        (LOG_ERROR, "Source file not found\n")log 
        1 return
    } (source_fd < 0) if

    null(Result*) = res Result*
    (source_fd)read_file = src byte*
    (source_fd)close

    (LOG_INFO, "Tokenizing file\n")log
    [src, [source_fn::settings, 1, 1], 0] = lexer Lexer
    (&lexer)tokenize = res

    { (err::res)print_error; 1 return} (err::res != null) if
    res::res(List*) = tokens List*
    (heap, src)heap_free
    (heap, res(void*))heap_free

    (LOG_INFO, "Parsing file\n")log
    [tokens, 0] = parser Parser
    (&parser, TT_EOF)parse = res

    { (err::res)print_error; 1 return} (err::res != null) if
    res::res(NodeRoot*) = ast NodeRoot*

    { (ast(Node*))display_ast } (debug::settings) if

    (heap, res(void*))heap_free
    (tokens)deconstruct_list
    (heap, tokens(void*))heap_free

    (LOG_INFO, "Validating program\n")log
    [0,0,null(Symbol**)] = table SymbolTable
    (&table, 65536)init_symboltable

    (ast, &table)validate = res
    { (err::res)print_error; 1 return } (err::res != null) if

    (LOG_INFO, "Generating assembly\n")log
    (ast, &table, output_fn::settings)generate = code int
    { 1 return } (code != 0) if
    0 return
} (argc int, argv byte**) main int

{
    false = found_source byte
    false = found_output byte

    {
        (argv + i * @void*) = arg byte**

        {
            true = debug::settings
            continue
        } (("-d", *arg)strcmp) if else
        { 
            0 = num long
            arg + @void* = arg
            
            {
                (LOG_ERROR, "Invalid argument for -m\n")log
                1 return
            } ((*arg, &num)try_parse_int) if

            num << 10 = memory::settings
            i + 1 = i
            continue
        } ( ("-m", *arg)strcmp ) if

        {
            *arg = output_fn::settings
            true = found_output
            continue
        } (!found_output) if else  
        {
            *arg = source_fn::settings
            true = found_source
            continue
        } (!found_source) if

        (*argv)print_usage
        1 return

    } (i + 1 = i; i < argc; 1 = i int) for

    { (*argv)print_usage; 1 return } (!found_source) if

    0 return
} (argc int, argv byte**, settings Settings*) parse_args int

{
    ("Usage: ")print
    (prog)print
    (" <source> [output]\n")print
    ("optional settings:\n")print
    ("  -m <limit>   set the available memory in kilobytes\n")print
    ("  -d           show debug information\n")print
    return
} (prog byte*) print_usage void

Position {
    file byte*
    line int
    column int
} struct

Error {
    msg byte*
    pos Position
} struct

{
    (LOG_ERROR, "")log
    (STDERR, file::pos::err)fprint; (STDERR, ":")fprint
    (STDERR, line::pos::err)fprint_num; (STDERR, ":")fprint
    (STDERR, column::pos::err)fprint_num; (STDERR, ": ")fprint
    (STDERR, msg::err)fprint
    return
} (err Error*) print_error void

Result {
    err Error*
    res void*
} struct

{
    { 
        err::that = err::this
        (heap, that(void*))heap_free
        null return
    } (err::that != null) if

    null(Error*) = err::this
    (heap, that(void*))heap_free
    res::that(void*) return
} (this Result*, that Result*) result_register void*

{
    (heap, @Error)heap_alloc(Error*) = err Error*
    [file::pos, line::pos, column::pos] = pos::err
    msg = msg::err
    err = err::this
    this return
} (this Result*, pos Position*, msg byte*) result_fail Result*

{
    null(Error*) = err::this
    res = res::this
    this return
} (this Result*, res void*) result_success Result*

#####################################################################
# List
#####################################################################

List {
    count int
    capacity int
    items void**
} struct

{
    {
        (items::_list + i * @void*) = Pitem void**
        (heap, *Pitem)heap_free
    } (i + 1 = i; i < count::_list; 0 = i int) for
    (heap, items::_list(void*))heap_free
    return
} (_list List*) deconstruct_list void

{
    {
        capacity::_list*2 = capacity::_list
        (heap, items::_list(void*), capacity::_list * @void*)heap_realloc(void**) = buf void**
        buf = items::_list
    } (count::_list == capacity::_list) if

    (items::_list + count::_list * @void*) = pos void**
    item = *pos 
    count::_list + 1 = count::_list
    return
} (_list List*, item void*) list_append void

{
    0 = count::_list
    8 = capacity::_list
    (heap, 8 * @void*)heap_alloc(void**) = buf void**
    buf = items::_list
    return
} (_list List*) init_list void

#####################################################################
# Lexer
#####################################################################

Token {
    type short
    data long
    pos Position
} struct

{
    { (LOG_WARN, "Exhaustive handling of token types in 'tt_to_str'\n")log } (TT_COUNT != 13) if
    null(byte*) = str byte*
    { "keyword"    = str } (type == TT_KEYWORD) if else
    { "identifier" = str } (type == TT_IDENT)   if else
    { "EOF"        = str } (type == TT_EOF)     if else
    { "newline"    = str } (type == TT_NEWLINE) if else
    { "int"        = str } (type == TT_INT)     if else
    { "')'"        = str } (type == TT_PARENR)  if else
    { "'('"        = str } (type == TT_PARENL)  if else 
    { "="          = str } (type == TT_EQ)      if else
    { "'%'"        = str } (type == TT_PERCENT) if else
    { "'/'"        = str } (type == TT_FSLASH)  if else
    { "'*'"        = str } (type == TT_STAR)    if else
    { "'-'"        = str } (type == TT_MIN)     if else
    { "'+'"        = str } (type == TT_PLUS)    if
    str return
} (type short) tt_to_str byte*

{
    -1 = prec byte
    { 5 = prec } (type == TT_PERCENT) if else
    { 5 = prec } (type == TT_FSLASH)  if else
    { 5 = prec } (type == TT_STAR)    if else
    { 4 = prec } (type == TT_MIN)     if else
    { 4 = prec } (type == TT_PLUS)    if
    prec return
} (type short) get_prec byte

Lexer {
    src byte*
    pos Position
    index long
} struct

{
    *(src::lexer + index::lexer) = c byte
    index::lexer + 1 = index::lexer
    column::pos::lexer + 1 = column::pos::lexer
    {
        1 = column::pos::lexer
        line::pos::lexer + 1 = line::pos::lexer
    } (c == 10) if
    c return
} (lexer Lexer*) lexer_consume byte

{
    *(src::lexer + index::lexer + offset) = c byte
    c return
} (lexer Lexer*, offset int) lexer_peek byte

{
    false = is_keyword byte
    is_keyword || (str, "if")strcmp = is_keyword
    is_keyword || (str, "while")strcmp = is_keyword
    is_keyword || (str, "for")strcmp = is_keyword
    is_keyword return
} (str byte*) is_keyword byte

{
    { (LOG_WARN, "Exhaustive handling of token types in 'tokenize'\n")log } (TT_COUNT != 15) if
    
    (heap, @List)heap_alloc(List*) = tokens List*
    (tokens)init_list

    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Error*) = err::res
    null(Token*) = tok Token*
    {
        (lexer, 0)lexer_peek = c byte
        {
            (lexer)lexer_consume
            continue
        } (c == 9 || c == 11 || c == 12 || c == 13 || c == 32) if

        (heap, @Token)heap_alloc(Token*) = tok
        [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::tok
        0 = type::tok
        0 = data::tok

        { 
            0 = n int
            {
                n * 10 = n
                n + (c - '0') = n
                (lexer, 1)lexer_peek = c 
                { break } ('9' < c || c < '0') if
                (lexer)lexer_consume
            } (true) while

            TT_INT = type::tok
            n = data::tok
        } ('9' >= c && c >= '0') if else
        {
            0 = i int
            (lexer, i)lexer_peek = nc byte
            { 
                i + 1 = i
                (lexer, i)lexer_peek = nc
            } ((nc >= 'A' && 'Z' >= nc) || (nc >= 'a' && 'z' >= nc) || ('9' >= nc && nc >= '0') || nc == '_') while

        (heap, i+1)heap_alloc(byte*) = ident byte*
        (src::lexer + index::lexer, ident, i)memcpy
        0 = *(ident + i)
        
        { (lexer)lexer_consume } (i - 1 = i; i > 1; i) for
        TT_IDENT = type::tok
        { TT_KEYWORD = type::tok } ((ident)is_keyword) if

        ident(long) = data::tok
        } ((c >= 'A' && 'Z' >= c) || (c >= 'a' && 'z' >= c) || c == '_') if else
        { TT_NEWLINE = type::tok } (c == ';') if else
        { TT_NEWLINE = type::tok } (c == 10 ) if else
        { TT_BRACKL  = type::tok } (c == '{') if else
        { TT_BRACKR  = type::tok } (c == '}') if else
        { TT_PARENL  = type::tok } (c == '(') if else
        { TT_PARENR  = type::tok } (c == ')') if else
        { TT_EQ      = type::tok } (c == '=') if else
        { TT_PERCENT = type::tok } (c == '%') if else
        { TT_FSLASH  = type::tok } (c == '/') if else
        { TT_STAR    = type::tok } (c == '*') if else
        { TT_MIN     = type::tok } (c == '-') if else 
        { TT_PLUS    = type::tok } (c == '+') if else
        {
            { (lexer)lexer_consume } ((lexer,0)lexer_peek != 10) while
            continue
        } (c == '#') if

        {
            (res, &pos::lexer, "Illegal character\n")result_fail return
        } (type::tok == 0) if 

        (tokens, tok(void*))list_append
        (lexer)lexer_consume
    } ((lexer, 0)lexer_peek) while 

    (heap, @Token)heap_alloc(Token*) = tok 
    [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::tok
    TT_EOF = type::tok
    (tokens, tok(void*))list_append

    (res, tokens(void*))result_success return
} (lexer Lexer*) tokenize Result*

#####################################################################
# Parser
#####################################################################

Node {
    type short
    pos  Position
} struct

NodeRoot {
    super    Node
    children List*
} struct

{
    (heap, @List)heap_alloc(List*) = children List*
    (heap, @NodeRoot)heap_alloc(NodeRoot*) = node NodeRoot*
    NODE_ROOT = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    (children)init_list
    children = children::node
    node return
} (pos Position*) create_node_root NodeRoot*

NodeUnop {
    super Node
    node  Node*
    op    short
} struct

{
    (heap, @NodeUnop)heap_alloc(NodeUnop*) = node NodeUnop*
    NODE_UNOP = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    _node = node::node
    op = op::node
    node return
} (pos Position*, _node Node*, op short) create_node_unop NodeUnop*

NodeBinop {
    super Node
    left  Node*
    op    short
    right Node*
} struct

{
    (heap, @NodeBinop)heap_alloc(NodeBinop*) = node NodeBinop*
    NODE_BINOP = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    left = left::node
    op = op::node
    right = right::node
    node return
} (pos Position*, left Node*, op short, right Node*) create_node_binop NodeBinop*

NodeIntLit {
    super Node
    val   long
} struct

{
    (heap, @NodeIntLit)heap_alloc(NodeIntLit*) = node NodeIntLit*
    NODE_INT_LIT = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    val = val::node
    node return
} (pos Position*, val long) create_node_int_lit NodeIntLit*

NodeVarDef {
    super Node
    name  byte*
    val   Node*
    type  byte*
} struct

{
    (heap, @NodeVarDef)heap_alloc(NodeVarDef*) = node NodeVarDef*
    NODE_VAR_DEF = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    val = val::node
    varType = type::node
    node return
} (pos Position*, name byte*, val Node*, varType byte*) create_node_var_def NodeVarDef*

NodeVarAssign {
    super Node
    name  byte*
    val   Node*
} struct

{
    (heap, @NodeVarAssign)heap_alloc(NodeVarAssign*) = node NodeVarAssign*
    NODE_VAR_ASSIGN = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    val = val::node
    node return
} (pos Position*, name byte*, val Node*) create_node_var_assign NodeVarAssign*

NodeVar {
    super Node
    name byte*
} struct

{
    (heap, @NodeVar)heap_alloc(NodeVar*) = node NodeVar*
    NODE_VAR = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    node return
} (pos Position*, name byte*) create_node_var NodeVar*

NodeIf {
    super     Node
    scope     Node*
    condition Node*
} struct

{
    (heap, @NodeIf)heap_alloc(NodeIf*) = node NodeIf*
    NODE_IF = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    condition = condition::node
    node return
} (pos Position*, scope Node*, condition Node*) create_node_if NodeIf*

NodeWhile {
    super     Node
    scope     Node*
    condition Node*
} struct

{
    (heap, @NodeWhile)heap_alloc(NodeWhile*) = node NodeWhile*
    NODE_WHILE = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    condition = condition::node
    node return
} (pos Position*, scope Node*, condition Node*) create_node_while NodeWhile*

NodeFor {
    super     Node
    scope     Node*
    on_loop   Node*
    condition Node*
    on_entry  Node*
} struct

{
    (heap, @NodeFor)heap_alloc(NodeFor*) = node NodeFor*
    NODE_FOR = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    on_loop = on_loop::node
    condition = condition::node
    on_entry = on_entry::node
    node return
} (pos Position*, scope Node*, on_loop Node*, condition Node*, on_entry Node*) create_node_for NodeFor*

Parser {
    tokens List*
    index long
} struct

{
    (items::tokens::parser + index::parser * @void*)(Token**) = Ptok Token**
    index::parser + 1 = index::parser
    *Ptok return
} (parser Parser*) parser_consume Token*

{
    (parser, 0)parser_peek = tok Token*
    { 
        (parser)parser_consume 
        tok return
    } (type::tok == type) if

    null(Token*) return
} (parser Parser*, type short) parser_consume_token Token*

{
    (parser, 0)parser_peek = tok Token*
    {  
        (parser)parser_consume
        (parser, 0)parser_peek = tok 
    } (type::tok == type) while
    return
} (parser Parser*, type short) parser_consume_all void

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Error*) = err::res
    (parser)parser_consume = tok Token*

    {
        (expected_type)tt_to_str = type byte*
        ("Expected ", type)strconcat = msg byte*
        (heap, msg(void*))heap_free
        (msg, "\n")strconcat = msg

        (res, &pos::tok, msg)result_fail return
    } (type::tok != expected_type) if

    tok(void*) = res::res
    res return
} (parser Parser*, expected_type short) parser_expect Result*

{
    (items::tokens::parser + (index::parser + offset) * @void*)(Token**) = Ptok Token**
    *Ptok return
} (parser Parser*, offset int) parser_peek Token*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*
    (&pos::tok)create_node_root = root NodeRoot*

    {
        (parser, TT_NEWLINE)parser_consume_all
        (parser, 0)parser_peek = tok 
        { break } ( type::tok == end ) if

        (res, (parser)parse_stmt)result_register = node void*
        { res return } (err::res != null) if 

        (children::root, node)list_append

        (parser, 0)parser_peek = tok
        {
            (res, &pos::tok, "Token cannot appear after previous token\n")result_fail return
        } (type::tok != TT_NEWLINE && type::tok != end) if

        { break } ( type::tok == end ) if
    } (true) while

    (res, root(void*))result_success return
} (parser Parser*, end short) parse Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*

    {
        (parser)parser_consume
        (parser)parse_scope_expr return
    } (type::tok == TT_BRACKL) if 

    (parser)parse_expr return
} (parser Parser*) parse_stmt Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*

    (res, (parser, TT_BRACKR)parse)result_register(Node*) = scope Node*
    { res return } (err::res != null) if 
    (parser)parser_consume

    (parser, 0)parser_peek = tok Token*
    {
        1 = parencount int
        1 = i int
        {
            (parser, i)parser_peek = tok
            { parencount + 1 = parencount } (type::tok == TT_PARENL) if
            { parencount - 1 = parencount } (type::tok == TT_PARENR) if
        } (i + 1 = i; parencount > 0; i) for
        (parser, i)parser_peek = tok
        
        {
            (res, &pos::tok, "Expected if, for, or while\n")result_fail return
        } (type::tok != TT_KEYWORD) if
    } (type::tok == TT_PARENL) if

    {
        (parser, scope)parse_if_expr return
    } ((data::tok(byte*), "if")strcmp) if

    {
        (parser, scope)parse_while_expr return
    } ((data::tok(byte*), "while")strcmp) if

    {
        (parser, scope)parse_for_expr return
    } ((data::tok(byte*), "for")strcmp) if

    (res, "Expected if, for, or while\n")result_success return
} (parser Parser*) parse_scope_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume

    (res, (parser)parse_expr)result_register(Node*) = condition Node*
    { res return } (err::res != null) if

    (res, (parser, TT_PARENR)parser_expect)result_register
    { res return } (err::res != null) if
    (parser)parser_consume = tok Token*

    (&pos::tok, scope, condition)create_node_if(Node*) = node Node*

    (res, node(void*))result_success return
} (parser Parser*, scope Node*) parse_if_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume

    (res, (parser)parse_expr)result_register(Node*) = condition Node*
    { res return } (err::res != null) if

    (res, (parser, TT_PARENR)parser_expect)result_register
    { res return } (err::res != null) if
    (parser)parser_consume = tok Token*

    (&pos::tok, scope, condition)create_node_while(Node*) = node Node*

    (res, node(void*))result_success return
} (parser Parser*, scope Node*) parse_while_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume
    (res, (parser)parse_expr)result_register(Node*) = on_loop Node*
    { res return } (err::res != null) if
    (res, (parser, TT_NEWLINE)parser_expect)result_register
    { res return } (err::res != null) if

    (res, (parser)parse_expr)result_register(Node*) = condition Node*
    { res return } (err::res != null) if
    (res, (parser, TT_NEWLINE)parser_expect)result_register
    { res return } (err::res != null) if

    (res, (parser)parse_expr)result_register(Node*) = on_entry Node*
    { res return } (err::res != null) if
    (res, (parser, TT_PARENR)parser_expect)result_register
    { res return } (err::res != null) if
    (parser)parser_consume = tok Token*

    (&pos::tok, scope, on_loop, condition, on_entry)create_node_for(Node*) = node Node*
    (res, node(void*))result_success return
} (parser Parser*, scope Node*) parse_for_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (res, (parser, 0)parse_bin_expr)result_register(Node*) = expr Node*

    {
        (parser, expr)parse_var_expr return
    } (type::((parser,0)parser_peek) == TT_EQ) if

    (res, expr(void*))result_success return
} (parser Parser*) parse_expr Result*

{
    (parser)parser_consume = _tok Token*

    (heap, @Result)heap_alloc(Result*) = res Result*
    (res, (parser, TT_IDENT)parser_expect)result_register(Token*) = tok Token*
    { res return } (err::res != null ) if 

    (parser, 0)parser_peek = varType Token*

    null(Node*) = node Node*

    {
        (&pos::_tok, data::tok(byte*), value)create_node_var_assign(Node*) = node
        (res, node(void*))result_success return
    } (type::varType != TT_IDENT) if

    (parser)parser_consume
    (&pos::_tok, data::tok(byte*), value, data::varType(byte*))create_node_var_def(Node*) = node

    (res, node(void*))result_success return
} (parser Parser*, value Node*) parse_var_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*

    (res, (parser)parse_atom)result_register = left void*
    { res return } (err::res != null) if 

    {

        (parser, 0)parser_peek = op Token*

        (type::op)get_prec = prec byte
        # prec will be -1 if the token type is not an operator
        # therefore the prec of a non operator token type will always be lower than min_prec
        { break } (prec < min_prec) if  
        (parser)parser_consume

        (res, (parser, prec + 1)parse_bin_expr)result_register = right void*
        { res return } (err::res != null) if 

        (&pos::op, left(Node*), type::op, right(Node*))create_node_binop(void*) = left
    } (true) while

    (res, left)result_success return
} (parser Parser*, min_prec byte) parse_bin_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*
    null(Node*) = node Node*

    {
        (parser)parser_consume
        (&pos::tok, data::tok(byte*))create_node_var(Node*) = node
    } (type::tok == TT_IDENT) if else
    {
        (parser)parser_consume
        (res, (parser)parse_atom)result_register(Node*) = node
        { res return } (err::res != null) if

        (&pos::tok, node(Node*), type::tok)create_node_unop(Node*) = node
    } (type::tok == TT_MIN) if else
    {
        (parser)parser_consume
        (res, (parser, 0)parse_bin_expr)result_register(Node*) = node
        { res return } (err::res != null) if
        (res, (parser, TT_PARENR)parser_expect)result_register
        { res return } (err::res != null) if
    } (type::tok == TT_PARENL) if else
    { 
        (&pos::tok, data::tok)create_node_int_lit(Node*) = node 
        (parser)parser_consume
    } (type::tok == TT_INT) if

    { 
        (res, &pos::tok, "Expected int, identifier, '-', or '('\n")result_fail return 
    } (node == null) if

    (res, node(void*))result_success return
} (parser Parser*) parse_atom Result*

{
    {
        node(NodeUnop*) = nodeUnop NodeUnop*
        ((op::nodeUnop)tt_to_str)print
        (node::nodeUnop(Node*))display_ast
    } (type::node == NODE_UNOP) if else
    {
        node(NodeIntLit*) = nodeIntLit NodeIntLit*
        (val::nodeIntLit)print_num
    } (type::node == NODE_INT_LIT) if else
    { 
        node(NodeBinop*) = nodeBinop NodeBinop*
        ("(")print 
        (left::nodeBinop(Node*))display_ast
        (op::nodeBinop)tt_to_str = type byte*
        (type)print
        (right::nodeBinop(Node*))display_ast
        (")")print 
    } (type::node == NODE_BINOP) if else
    { 
        node(NodeRoot*) = nodeRoot NodeRoot*
        {
            (items::children::(nodeRoot) + i * @void*)(Node**) = Pnode Node**
            *Pnode = _node Node*
            (_node)display_ast
            ("\n")print
        } (i + 1 = i; i < count::children::nodeRoot; 0 = i int) for
    } (type::node == NODE_ROOT) if
    return
} (node Node*) display_ast void

#####################################################################
# Symboltable
#####################################################################

Symbol {
    type short
    name byte*
    next void* # Symbol*
} struct

Type {
    super     Symbol
    sizeBytes int
    size      int
} struct

Var {
    super Symbol
    pos   long
    type  Type*
} struct

SymbolTable {
    size  long
    stack long
    items Symbol**
} struct

{
    5381 = hash long
    {
        ((hash << 5) + hash) + c = hash
    } (i + 1 = i; *(str + i) = c byte; 0 = i int) for

    hash return
} (str byte*) hash long

{
    ((a%b)+b)%b return
} (a long, b long) umod long 

{
    size = size::table
    (heap, size * @void*)heap_alloc(Symbol**) = items Symbol**
    items = items::table 
    (items::table(void*), 0, size::table * @void*)memset
    return
} (table SymbolTable*, size long) init_symboltable void

{
    (name::symbol)hash = _hash long
    (_hash, size::table)umod = index long

    (items::table + index * @void*) = Psymbol Symbol**
    *Psymbol = _symbol Symbol*

    {
        { return } ((name::_symbol, name::symbol)strcmp) if
        { next::_symbol = next::symbol } (next::_symbol != null) if
        symbol(void*) = next::_symbol
        return
    } (_symbol) if

    symbol = *Psymbol
    return
} (table SymbolTable*, symbol Symbol*) add_symbol void

{
    (heap, @Var)heap_alloc(Var*) = var Var*
    VAR = type::super::var
    name = name::super::var
    null = next::super::var
    varType = type::var

    stack::table + sizeBytes::varType = stack::table
    -stack::table = pos::var
    (table, var(Symbol*))add_symbol
    return
} (table SymbolTable*, name byte*, varType Type*) add_var void

{
    (heap, @Type)heap_alloc(Type*) = builtin Type*
    BUILTIN = type::super::builtin
    name = name::super::builtin
    null = next::super::builtin
    size = size::builtin
    sizeBytes = sizeBytes::builtin

    (table, builtin(Symbol*))add_symbol
    return
} (table SymbolTable*, name byte*, size int, sizeBytes int) add_builtin void

{
    (name)hash = _hash long
    (_hash, size::table)umod = index long

    (items::table + index * @void*) = Psymbol Symbol**
    *Psymbol return
} (table SymbolTable*, name byte*) get_symbol Symbol*

#####################################################################
# Validator
#####################################################################

ValContext {
    table SymbolTable*
} struct

{
    (table, "long", QWORD, 8)add_builtin
    (table, "int",  DWORD, 4)add_builtin
    (table, "short", WORD, 2)add_builtin
    (table, "byte",  BYTE, 1)add_builtin

    [table] = ctx ValContext
    (node(Node*),&ctx)valvisit = res Result*
    res return
} (node NodeRoot*, table SymbolTable*) validate Result*

{
    (table, name)get_symbol = symbol Symbol*

    {
        null(Symbol*) return
    } (type::symbol != BUILTIN) if

    symbol return
} (table SymbolTable*, name byte*) get_type Symbol*

{
    { (node(NodeFor*),ctx)valvisit_NodeFor             return } (type::node == NODE_FOR)        if else
    { (node(NodeWhile*),ctx)valvisit_NodeWhile         return } (type::node == NODE_WHILE)      if else
    { (node(NodeIf*),ctx)valvisit_NodeIf               return } (type::node == NODE_IF)         if else
    { (node(NodeVar*),ctx)valvisit_NodeVar             return } (type::node == NODE_VAR)        if else
    { (node(NodeVarAssign*),ctx)valvisit_NodeVarAssign return } (type::node == NODE_VAR_ASSIGN) if else
    { (node(NodeVarDef*),ctx)valvisit_NodeVarDef       return } (type::node == NODE_VAR_DEF)    if else
    { (node(NodeUnop*),ctx)valvisit_NodeUnop           return } (type::node == NODE_UNOP)       if else
    { (node(NodeIntLit*),ctx)valvisit_NodeIntLit       return } (type::node == NODE_INT_LIT)    if else
    { (node(NodeBinop*),ctx)valvisit_NodeBinop         return } (type::node == NODE_BINOP)      if else
    { (node(NodeRoot*),ctx)valvisit_NodeRoot           return } (type::node == NODE_ROOT)       if
    null(Result*) return
} (node Node*, ctx ValContext*) valvisit Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    {
        (items::children::node + i * @void*)(Node**) = Pnode Node**
        (res, (*Pnode, ctx)valvisit)result_register
        { res return } (err::res != null) if
    } (i + 1 = i; i < count::children::node; 0 = i int) for

    (res, null)result_success return
} (node NodeRoot*, ctx ValContext*) valvisit_NodeRoot Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (res, (left::node, ctx)valvisit)result_register(Type*) = leftType Type*
    {res return } (err::res != null) if

    (res, (right::node, ctx)valvisit)result_register(Type*) = rightType Type*
    {res return } (err::res != null) if

    (res, leftType(void*))result_success return
} (node NodeBinop*, ctx ValContext*) valvisit_NodeBinop Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (res, (table::ctx, "long")get_symbol(void*))result_success return
} (node NodeIntLit*, ctx ValContext*) valvisit_NodeIntLit Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    
    (res, (node::node, ctx)valvisit)result_register(Type*) = type Type*
    {res return } (err::res != null) if

    (res, type(void*))result_success return
} (node NodeUnop*, ctx ValContext*) valvisit_NodeUnop Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (table::ctx, name::node)get_symbol = symbol Symbol*
    
    (res, (val::node, ctx)valvisit)result_register
    {res return } (err::res != null) if

    { 
        name::node = name byte*
        (res, &pos::super::node, ("'%' is already defined\n", &name, 1)strformat)result_fail return
    } (symbol != null) if

    (table::ctx, type::node)get_type(Type*) = varType Type*

    {
        type::node = type byte*
        (res, &pos::super::node, ("'%' is not a type\n", &type, 1)strformat)result_fail return
    } (varType == null) if

    (table::ctx, name::node, varType)add_var

    (res, varType(void*))result_success return
} (node NodeVarDef*, ctx ValContext*) valvisit_NodeVarDef Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (table::ctx, name::node)get_symbol(Var*) = var Var*

    (res, (val::node, ctx)valvisit)result_register
    {res return } (err::res != null) if

    { 
        name::node = name byte*
        (res, &pos::super::node, ("'%' is not defined\n", &name, 1)strformat)result_fail return
    } (var == null) if
    (res, type::var(void*))result_success return
} (node NodeVarAssign*, ctx ValContext*) valvisit_NodeVarAssign Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (table::ctx, name::node)get_symbol(Var*) = var Var*

    { 
        name::node = name byte*
        (res, &pos::super::node, ("'%' is not defined\n", &name, 1)strformat)result_fail return
    } (var == null) if
    (res, type::var(void*))result_success return
} (node NodeVar*, ctx ValContext*) valvisit_NodeVar Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (res, (scope::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, (condition::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, null)result_success return
} (node NodeIf*, ctx ValContext*) valvisit_NodeIf Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (res, (scope::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, (condition::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, null)result_success return
} (node NodeWhile*, ctx ValContext*) valvisit_NodeWhile Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (res, (scope::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, (on_entry::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, (condition::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, (on_loop::node, ctx)valvisit)result_register
    { res return } (err::res != null) if
    (res, null)result_success return
} (node NodeFor*, ctx ValContext*) valvisit_NodeFor Result*

#####################################################################
# Generator
#####################################################################

Value {
    type short
    str  byte*
} struct

Reg {
    super Value
    reg   short
    size  short
} struct

{
    (heap, @Reg)heap_alloc(Reg*) = reg Reg*
    REG = type::super::reg
    _reg = reg::reg
    size = size::reg

    reg::reg*4 + size::reg = index int
    (regs - index * @void*)(byte**) = PStr byte**
    *PStr = str::super::reg
    reg return
} (_reg short, size short) create_reg Reg*

Mempos {
    super  Value
    reg    short
    size   short
    offset long
} struct

{
    (heap, @Mempos)heap_alloc(Mempos*) = mempos Mempos*
    MEMPOS = type::super::mempos
    reg = reg::mempos
    size = size::mempos
    offset = offset::mempos

    (sizes - size * @void*) = PSize byte**
    *PSize = sizeStr byte*
    (regs - reg*4 * @void*) = PReg byte**
    *PReg = regStr byte*
    "+" = sign byte*
    { "-" = sign; -offset = offset } (offset < 0) if
    (offset)itoa = offsetStr byte*

    offsetStr = str4 byte*; sign = str3 byte*; *PReg = str2 byte*; *PSize = str1 byte*
    ("%[%%%]", &str1, 4)strformat = str byte*
    str = str::super::mempos
    (heap, offsetStr(void*))heap_free
    mempos return
} (reg short, size short, offset long) create_mempos Mempos*

{
    (table, name)get_symbol(Var*) = symbol Var*
    { null(Mempos*) return } (type::super::symbol != VAR) if

    (RBP, size::type::symbol, pos::symbol)create_mempos return
} (table SymbolTable*, name byte*) get_var_pos Mempos*

ImmValue {
    super Value
    val   long
} struct

{
    (heap, @ImmValue)heap_alloc(ImmValue*) = immvalue ImmValue*
    IMMVALUE = type::super::immvalue
    value = val::immvalue
    (value)itoa = str byte*
    str = str::super::immvalue
    immvalue return
} (value long) create_immvalue ImmValue*

{
    true = is_equal byte
    
    (type::val1 == type::val2) = is_equal
    { is_equal return } (!is_equal) if

    (str::val1, str::val2)strcmp = is_equal
    is_equal return
} (val1 Value*, val2 Value*) value_equals byte

{
    {
        (heap, str::value)heap_free
    } (type::value == IMMVALUE || type::value == MEMPOS) if
    (heap, value(void*))heap_free
    return
} (value Value*) destroy void

GenContext {
    table SymbolTable*
} struct

{
    false = _uses_reg byte
    {
       _uses_reg || (reg::reg == RAX && lhs)  = _uses_reg
       _uses_reg || (reg::reg == RDI && !lhs) = _uses_reg 
    } (type::node == NODE_UNOP) if else
    {
        node(NodeBinop*) = nodeBinop NodeBinop*
        _uses_reg || (left::nodeBinop,  true,  reg)uses_reg = _uses_reg
        _uses_reg || (right::nodeBinop, false, reg)uses_reg = _uses_reg

        _uses_reg || (!lhs && reg::reg == RDI) = _uses_reg 
        _uses_reg || (lhs  && reg::reg == RAX) = _uses_reg
        _uses_reg || reg::reg == RCX = _uses_reg
    } (type::node == NODE_BINOP) if
    _uses_reg return
} (node Node*, lhs byte, reg Reg*) uses_reg byte 

{
    (heap, @FileBuffer)heap_alloc(FileBuffer*) = fbuf FileBuffer*
    (fbuf, fn, 256 << 10)open_file_buffer = code int

    { (LOG_ERROR, "Could not open output file\n")log; 1 return } (code == 1) if
    { (LOG_ERROR, "Could not allocate file buffer\n")log; 1 return } (code == 2) if

    (fbuf, "format ELF64 executable\nsegment readable executable\nentry $\n")write_file_buffer
    (fbuf, "mov rbp, rsp\n")write_file_buffer

    [table] = ctx GenContext
    (ast(Node*), true, &ctx, fbuf)visit

    (fbuf, "mov rdi,0\nmov rax,60\nsyscall")write_file_buffer

    (fbuf)close_file_buffer
    (heap, fbuf(void*))heap_free
    0 return
} (ast NodeRoot*, table SymbolTable*, fn byte*) generate int

{
    { (node(NodeFor*),ctx,fbuf)visit_NodeFor             return } (type::node == NODE_FOR)        if else
    { (node(NodeWhile*),ctx,fbuf)visit_NodeWhile         return } (type::node == NODE_WHILE)      if else
    { (node(NodeIf*),ctx,fbuf)visit_NodeIf               return } (type::node == NODE_IF)         if else
    { (node(NodeVar*),ctx,fbuf)visit_NodeVar             return } (type::node == NODE_VAR)        if else
    { (node(NodeVarAssign*),ctx,fbuf)visit_NodeVarAssign return } (type::node == NODE_VAR_ASSIGN) if else
    { (node(NodeVarAssign*),ctx,fbuf)visit_NodeVarAssign return } (type::node == NODE_VAR_DEF)    if else
    { (node(NodeUnop*),lhs,ctx,fbuf)visit_NodeUnop       return } (type::node == NODE_UNOP)       if else
    { (node(NodeIntLit*),ctx,fbuf)visit_NodeIntLit       return } (type::node == NODE_INT_LIT)    if else
    { (node(NodeBinop*),lhs,ctx,fbuf)visit_NodeBinop     return } (type::node == NODE_BINOP)      if else
    { (node(NodeRoot*),ctx,fbuf)visit_NodeRoot           return } (type::node == NODE_ROOT)       if
    null(Value*) return
} (node Node*, lhs byte, ctx GenContext*, fbuf FileBuffer*) visit Value*

{
    {
        (items::children::node + i * @void*)(Node**) = Pnode Node**
        (*Pnode, true, ctx, fbuf)visit = value Value*
        { (value)destroy } (value != null) if
    } (i + 1 = i; i < count::children::node; 0 = i int) for

    null(Value*) return
} (node NodeRoot*, ctx GenContext*, fbuf FileBuffer*) visit_NodeRoot Value*

{
    ((false)iota)itoa = forStart byte*
    ((false)iota)itoa = forLoop  byte*
    ((false)iota)itoa = forCond  byte*
    ((false)iota)itoa = forEnd   byte*

    null = _ void*
    (on_entry::node, true, ctx, fbuf)visit(void*) = _
    (_(Value*))destroy

    null(byte*) = str3 byte*; forStart = str2 byte*; forCond = str1 byte*
    (fbuf, "jmp L%\nL%:\n", &str1, 2)write_file_bufferf

    (scope::node, true, ctx, fbuf)visit(void*)

    (fbuf, "L%:\n", &forLoop, 1)write_file_bufferf

    (on_loop::node, true, ctx, fbuf)visit(void*) = _
    (_(Value*))destroy

    (fbuf, "L%:\n", &forCond, 1)write_file_bufferf

    (condition::node, true, ctx, fbuf)visit = condition Value*

    forEnd = str3; forStart = str2; str::condition = str1
    (fbuf, "cmp %,0\njne L%\nL%:\n", &str1, 3)write_file_bufferf

    (condition)destroy
    (heap, forStart(void*))heap_free
    (heap, forLoop(void*))heap_free
    (heap, forCond(void*))heap_free
    (heap, forEnd(void*))heap_free
    null(Value*) return
} (node NodeFor*, ctx GenContext*, fbuf FileBuffer*) visit_NodeFor Value*

{   
    ((false)iota)itoa = whileStart byte*
    ((false)iota)itoa = whileCond  byte*
    ((false)iota)itoa = whileEnd   byte*

    (fbuf, "jmp L%\nL%:\n", &whileCond, 2)write_file_bufferf
    (scope::node, true, ctx, fbuf)visit
    (fbuf, "L%:\n", &whileCond, 1)write_file_bufferf

    (condition::node, true, ctx, fbuf)visit = condition Value*
    whileEnd = str3 byte*; whileStart = str2 byte*; str::condition = str1 byte*

    { 
        (RAX, QWORD)create_reg(Value*) = reg Value*
        (reg, condition, fbuf)move
        str::reg = str1
        (reg)destroy 
    } (type::condition == IMMVALUE) if

    (fbuf, "cmp %,0\njne L%\nL%:\n", &str1, 3)write_file_bufferf

    (condition)destroy
    (heap, whileStart(void*))heap_free
    (heap, whileCond(void*))heap_free
    (heap, whileEnd(void*))heap_free
    null(Value*) return
} (node NodeWhile*, ctx GenContext*, fbuf FileBuffer*)visit_NodeWhile Value*

{
    (condition::node, true, ctx, fbuf)visit = condition Value*

    ((false)iota)itoa = ifEnd byte*
    str::condition = conditionStr byte*

    (fbuf, "cmp %,0\nje L%\n", &conditionStr, 2)write_file_bufferf

    (scope::node, true, ctx, fbuf)visit

    (fbuf, "L%:\n", &ifEnd, 1)write_file_bufferf
    (heap, ifEnd(void*))heap_free
    (condition)destroy
    null(Value*) return
} (node NodeIf*, ctx GenContext*, fbuf FileBuffer*) visit_NodeIf Value*

{
    (table::ctx, name::node)get_var_pos = pos Mempos*
    pos(Value*) return
} (node NodeVar*, ctx GenContext*, fbuf FileBuffer*) visit_NodeVar Value*

{
    (val::node, true, ctx, fbuf)visit = val Value*
    (table::ctx, name::node)get_var_pos = pos Mempos*
    (pos(Value*), val, fbuf)move
    (pos(Value*))destroy
    val return
} (node NodeVarAssign*, ctx GenContext*, fbuf FileBuffer*) visit_NodeVarAssign Value*

{
    (node::node, true, ctx, fbuf)visit = value Value*
    RAX = _reg short
    { RDI = _reg } (!lhs) if

    (_reg, QWORD)create_reg = reg Reg*
    (op::node, value, reg, fbuf)unary_instr = res Value*
    (value)destroy
    res return
} (node NodeUnop*, lhs byte, ctx GenContext*, fbuf FileBuffer*) visit_NodeUnop Value*

{
    (left::node, true, ctx, fbuf)visit = left Value*

    QWORD = regSize short
    {
        left(Mempos*) = mempos Mempos*
        size::mempos = regSize
    } (type::left == MEMPOS) if


    null(Reg*) = reg Reg*
    { (RDI, regSize)create_reg = reg } else
    { (RAX, regSize)create_reg = reg } (lhs) if

    { 
        (R10, QWORD)create_reg = new_reg Reg*
        (new_reg(Value*), reg(Value*), fbuf)move(Reg*)
        (reg(Value*))destroy
        new_reg = reg
        {
            (left)destroy
            reg(Value*) = left
        } (type::left == REG) if
    } ((right::node, false, reg)uses_reg) if

    (right::node, false, ctx, fbuf)visit = right Value*
    (op::node, left, right, reg, fbuf)bin_instr(Reg*) = reg

    (left)destroy
    (right)destroy
    reg(Value*) return
} (node NodeBinop*, lhs byte, ctx GenContext*, fbuf FileBuffer*) visit_NodeBinop Value*

{
    (val::node)create_immvalue(Value*) return
} (node NodeIntLit*, ctx GenContext*, fbuf FileBuffer*) visit_NodeIntLit Value*

{
    "mov " = instr byte*

    dest = _dest Value*
    src = _src Value*
    null(Mempos*) = destMempos Mempos* 
    null(Mempos*) = srcMempos Mempos* 
    null(Reg*) = destReg Reg*
    null(Reg*) = srcReg Reg*

    { 
        dest(Reg*) = destReg
        src(Reg*) = srcReg
        { dest return } (reg::destReg == reg::srcReg && size::destReg >= size::srcReg) if
        {
            (reg::srcReg, size::destReg)create_reg(Value*) = src
        } (size::destReg > size::srcReg) if
    }  ((type::dest == REG && type::src == REG)) if

    {
        dest(Mempos*) = destMempos
        src(Mempos*) = srcMempos
        (RAX, size::srcMempos)create_reg(Value*) = r Value*
        (r, src, fbuf)move = src
        (r)destroy
    } (type::dest == MEMPOS && type::src == MEMPOS) if
    
    {
        dest(Mempos*) = destMempos
        src(Reg*) = srcReg
        {
            (reg::srcReg, size::destMempos)create_reg(Value*) = src
        } (size::destMempos > size::srcReg) if

        {
            (reg::srcReg, size::destMempos)create_reg(Value*) = src
            (src, _src, fbuf)move
        } (size::destMempos < size::srcReg) if
    } (type::dest == MEMPOS && type::src == REG) if

    {
        dest(Reg*) = destReg
        src(Mempos*) = srcMempos

        {
            (reg::destReg, size::srcMempos)create_reg(Value*) = dest
        } (size::destReg > size::srcMempos) if
    } (type::dest == REG && type::src == MEMPOS) if

    {
        dest(Reg*) = destReg
        src(Reg*) = srcReg
        {
            "movsx " = instr
        } (size::destReg < size::srcReg) if

        {
            "movsxd " = instr
        } (size::destReg == QWORD && size::srcReg == DWORD) if
    } ((type::dest == REG) && (type::src == REG || type::src == MEMPOS)) if

    (fbuf, instr)write_file_buffer
    (fbuf, str::dest)write_file_buffer
    (fbuf, ",")write_file_buffer
    (fbuf, str::src)write_file_buffer
    (fbuf, "\n")write_file_buffer
    { (heap, dest(void*))heap_free } (_dest != dest) if
    { (heap,  src(void*))heap_free } (_src  != src)  if
    _dest return
} (dest Value*, src Value*, fbuf FileBuffer*) move Value*

{
    { 
        (reg(Value*), arg, fbuf)move
        reg(Value*) = arg
    } (type::arg != REG) if
    null(byte*) = instr byte*

    { "neg " = instr} (_instr == TT_MIN) if

    (fbuf, instr)write_file_buffer
    (fbuf, str::arg)write_file_buffer
    (fbuf, "\n")write_file_buffer
    arg return
} (_instr short, arg Value*, reg Reg*, fbuf FileBuffer*) unary_instr Value*

{
    arg2 = _arg2 Value*
    { 
        (reg(Value*), arg1, fbuf)move
        reg(Value*) = arg1
    } (type::arg1 != REG) if
    null(byte*) = instr byte*

    {
        arg2(Mempos*) = mempos Mempos*
        {
            (RCX, size::(arg1(Reg*)))create_reg(Value*) = arg2
            (arg2, mempos(Value*), fbuf)move
        } (size::mempos != size::(arg1(Reg*))) if
    } (type::arg2 == MEMPOS) if

    {
        (RDI, size::(arg1(Reg*)))create_reg = divisor Reg*
        (divisor(Value*), arg2, fbuf)move
        
        (RAX, size::(arg1(Reg*)))create_reg = dividend Reg*
        (dividend(Value*), arg1, fbuf)move(Value*) = arg1

        (fbuf, "cqo\n")write_file_buffer
        (fbuf, "idiv ")write_file_buffer
        (fbuf, str::super::divisor)write_file_buffer
        (fbuf, "\n")write_file_buffer

        (divisor(Value*))destroy

        { 
            (RDX, size::dividend)create_reg = r Reg*
            (dividend(Value*))destroy
            r(Value*) return
        } (_instr == TT_PERCENT) if
        arg1 return
    } (_instr == TT_FSLASH || _instr == TT_PERCENT) if

    { "sub "  = instr } (_instr == TT_MIN)  if else
    { "imul " = instr } (_instr == TT_STAR) if else
    { "add "  = instr } (_instr == TT_PLUS) if

    (fbuf, instr)write_file_buffer
    (fbuf, str::arg1)write_file_buffer
    (fbuf, ",")write_file_buffer
    (fbuf, str::arg2)write_file_buffer
    (fbuf, "\n")write_file_buffer

    { (heap, arg2(void*))heap_free } (arg2 != _arg2) if
    arg1 return
} (_instr short, arg1 Value*, arg2 Value*, reg Reg*, fbuf FileBuffer*) bin_instr Value*

#####################################################################
# other
#####################################################################

FileBuffer {
    fd    int
    buf   byte*
    cap   long
    count long
} struct

# returns 1 when file cannot be opened
# returns 2 when the buffer cant be allocated
{
    (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, O_WRONLY | O_CREAT | O_TRUNC, filename)open = fd int
    { 1 return } (fd < 0) if

    fd = fd::fb
    0 = count::fb
    (heap, bufsize)heap_alloc = buf byte*

    { 2 return } (buf == null) if

    bufsize = cap::fb
    buf = buf::fb
    0 return
} (fb FileBuffer*, filename byte*, bufsize long) open_file_buffer int

{
    (fb)flush_file_buffer
    (fd::fb)close
    (heap, buf::fb(void*))heap_free
    0 = cap::fb
    return
} (fb FileBuffer*) close_file_buffer void

{
    (count::fb, buf::fb, fd::fb)write
    0 = count::fb
    return
} (fb FileBuffer*) flush_file_buffer void

{
    (buf)strlen = buflen long
    { (fbuf)flush_file_buffer } (buflen + count::fbuf > cap::fbuf) if
    (buf(void*), buf::fbuf + count::fbuf, buflen)memcpy
    count::fbuf + buflen = count::fbuf
    return
} (fbuf FileBuffer*, buf byte*) write_file_buffer void

{
    (template, argv, argc)strformat = str byte*
    (fbuf, str)write_file_buffer
    (heap, str(void*))heap_free
    return
} (fbuf FileBuffer*, template byte*, argv byte**, argc int) write_file_bufferf void

{
    0 = argc long
    # argc is stored at [rsp + 24]
    # this is because the variable argc takes up 8 bytes
    # rbp gets pushed onto the stack at the start of a function taking up 8 bytes
    # and the return adress get pushed onto the stack when calling the function also taking up 8 bytes
    asm("mov rax, [rsp + 24]")
    asm("mov [rbp - 8], rax")
    argc return
} () get_argc long

{
    0(byte**) = argv byte**
    # the pointer to the first argument is stored at [rsp + 32]
    # because argc is stored at [rsp + 24], and takes up 8 bytes
    # see explanation in get_argc
    asm("lea rax, [rsp + 32]")
    asm("mov [rbp - 8], rax")
    argv return
} () get_argv byte**

{
    [0] = statbuf stat
    (&statbuf, fd)fstat
    st_size::statbuf = size long
    (heap, size+1)heap_alloc(byte*) = buf byte*
    (size, buf, fd)read 
    0 = *(buf + size + 1)
    buf return
} (fd int) read_file byte*

{
    STDOUT = fd int
    { STDERR = fd } (log_level == LOG_ERROR) if
    { (fd, "[ERROR] ")fprint } (log_level == LOG_ERROR) if else
    { (fd, "[WARN] ")fprint  } (log_level == LOG_WARN)  if else
    { (fd, "[INFO] ")fprint  } (log_level == LOG_INFO)  if
    (str)print
    return
} (log_level int, str byte*)log void

{
    (str)strlen = len long
    (len, str, 1)write
    return
} (str byte*) print void

{
    (str)strlen = len long
    (len, str, fd)write
    return
} (fd int, str byte*) fprint void

{
    (num)itoa = str byte*
    (str)print
    (heap, str(void*))heap_free
    return
} (num long) print_num void

{
    (num)itoa = str byte*
    (fd, str)fprint
    (heap, str(void*))heap_free
    return
} (fd int, num long) fprint_num void

{
    false = is_neg byte
    { -num = num; true = is_neg } (num < 0) if
    (num)log10l = log10 int
    (num >= (10, log10)pow) || num < 8 = x long
    log10 + x + is_neg = length int

    (heap, length + 1)heap_alloc(byte*) = str byte*
    0 = *(str + length)

    {
        { 0 = *(str + i); continue } (i == length) if

        num % 10 = digit byte
        num / 10 = num

        digit + '0' = digit
        digit = *(str + i)
    } (i - 1 = i; i >= 0; length = i int) for

    {'-' = *str } (is_neg) if
    str return
} (num long) itoa byte*

{   
    0 = len long
    { len + 1 = len } (*(str + len)) while
    len return
} (str byte*) strlen long

{
    (str1)strlen = str1len long
    (str2)strlen = str2len long
    { false return } (str1len != str2len) if
    true = is_equal byte

    {
        (*(str1 + i) == *(str2 + i)) = is_equal
        { break } (!is_equal) if
    } (i + 1 = i; i < str1len; 0 = i int) for

    is_equal return
} (str1 byte*, str2 byte*) strcmp byte

{
    (str1)strlen = str1len long
    (str2)strlen = str2len long
    (heap, str1len + str2len + 1)heap_alloc = str byte*

    0 = i int
    { *(str1 + i) = *(str + i) }         (i + 1 = i; i < str1len;i)         for
    { *(str2 + i-str1len) = *(str + i) } (i + 1 = i; i < str1len+str2len;i) for
    0 = *(str + i)
    str return
} (str1 byte*, str2 byte*) strconcat byte*

{
    (template)strlen = template_len long
    template_len - argc = len long
    0 = i int
    {
        (argv + i * @void*) = arg byte**
        (*arg)strlen + len = len
    } (i + 1 = i; i < argc; i) for
    
    (heap, len+1)heap_alloc(byte*) = buf byte*
    
    0 = j int
    0 = argindex int
    {
        *(template + i) = c byte
        
        {
            (argv + argindex * @void*) = arg 
            *arg = str byte*
            (str)strlen = N int
            {
                *(str + n) = *(buf + j)
                j + 1 = j
            } (n + 1 = n; n < N; 0 = n int) for
            argindex + 1 = argindex
            continue
        } (c == '%' && argindex < argc) if

        c = *(buf + j)
        j + 1 = j
    } (i + 1 = i; i < template_len; 0 = i) for
    0 = *(buf + len)
    buf return
} (template byte*, argv byte**, argc int) strformat byte*

{
    (src)strlen = len long
    
    {
        *(src + i) = x byte
        x = *(dest + i)
        { break } (!x) if
    } (i + 1 = i; true; 0 = i long) for  
    return
} (src byte*, dest byte*) strcpy void

{
    0 = i long
    count % 8 = n long

    {
        *(src(long*) + i) = *(dest(long*) + i)
    } (i + 8 = i; i < count-n && count > 8; i) for

    { *(src(int*)   + i) = *(dest(int*)   + i); n - 4 = n; i + 4 = i } (n >= 4) if
    { *(src(short*) + i) = *(dest(short*) + i); n - 2 = n; i + 2 = i } (n >= 2) if
    { *(src(byte*)  + i) = *(dest(byte*)  + i); n - 1 = n; i + 1 = i } (n >= 1) if

    return
} (src void*, dest void*, count long) memcpy void

{
    {
        val = *((dest + i)(byte*))
    } (i + 1 = i; i < count; 0 = i long) for

    return
} (dest void*, val byte, count long) memset void

{
    (str)strlen = len long
    0 = *res

    {
        *res * 10 = *res
        *(str + i) = n long
        { break } (n == 0) if
        { 1 return } (n > '9' || n < '0') if

        n - '0' = n
        n + *res = *res
    } (i + 1 = i; i < len; 0 = i int) for

    0 return
} (str byte*, res long*) try_parse_int byte

{
    0 = y int 
    64 = n int
    x >> 32 = y; {n - 32 = n; y = x } (y != 0) if
    x >> 16 = y; {n - 16 = n; y = x } (y != 0) if
    x >> 8 = y; { n - 8 = n; y = x } (y != 0) if
    x >> 4 = y; { n - 4 = n; y = x } (y != 0) if
    x >> 2 = y; { n - 2 = n; y = x } (y != 0) if
    x >> 1 = y; { n - 2 return } (y != 0) if
    n - x return
} (x long) clzl long

{
    { 0 return } (x == 0) if
    63 - (x)clzl return
} (x long) log2l long

{
    (x)log2l / (10)log2l return
} (x long) log10l long

{
    x = n int
    { n * x = n } (i + 1 = i; i < pow; 1 = i int) for
    n return
} (x long, pow long) pow long

{
    _iota = n long
    { _iota + 1 = _iota } else { 0 = _iota } (reset) if
    n return
} (reset byte) iota long

#####################################################################
# syscalls
#####################################################################
stat {
    st_dev        long
    st_ino        long
    st_nlink      long
    st_mode       int
    st_uid        int
    st_gid        int
    __pad0        int
    st_rdev       long
    st_size       long
    st_blksize    long
    st_blocks     long
    st_atime      long
    st_atime_nsec long
    st_mtime      long
    st_mtime_nsec long
    st_ctime      long
    st_ctime_nsec long
    __unused1     long
    __unused2     long
    __unused3     long
} struct

{
    asm("mov rax, 0")
    asm("syscall")
    return
} (count long, buf byte*, fd int) read void

{
    asm("mov rax, 1")
    asm("syscall")
    return
} (count long, buf byte*, fd int) write void

{
    -1 = fd int
    asm("mov rax, 2")
    asm("syscall")
    asm("mov [rbp - 24], eax")
    fd return
} (mode long, flags int, fn byte*) open int

{
    asm("mov rax, 3")
    asm("syscall")
    return
} (fd int) close void

{
    asm("mov rax, 5")
    asm("syscall")
    return
} (statbuf stat*, fd int) fstat void

{   
    null = mem void* 
    asm("mov r10, rcx")
    asm("mov rax, 9")
    asm("syscall")
    asm("mov [rbp - 44], rax")
    mem return
} (offset long, fd int, flags int, prot int, len long, addr void*) mmap void*

{
    asm("mov rax, 60")
    asm("syscall")
    return
} (code long) exit void

#####################################################################
# malloc
#####################################################################

heapchunk_t {
    size long
    start void*
    inuse byte
} struct

heapinfo_t {
    chunks heapchunk_t*
    nchunks long
    chunks_cap long
    memory void*
} struct

{
    nchunks::heap = nchunks long

    ("========================================================================\n")print
    {
        (chunks::heap + i * @heapchunk_t) = Pchunk heapchunk_t*
        ("[")print; (i)print_num; ("] ")print
        ("start: ")print; (start::Pchunk(long))print_num
        (", ")print; ("size: ")print; (size::Pchunk)print_num
        (", ")print; ("inuse: ")print
        { ("false")print } else { ("true")print } (inuse::Pchunk) if
        ("\n")print

    } (i + 1 = i; i < nchunks; 0 = i int) for
    ("========================================================================\n")print

    return
} (heap heapinfo_t*) display_heap void

{       
    { 1 return } (size < 1024) if

    (0, -1, MAP_PRIVATE | MAP_ANONYMOUS, PROT_READ | PROT_WRITE, size, null) mmap = memory_start void*
    (0, -1, MAP_PRIVATE | MAP_ANONYMOUS, PROT_READ | PROT_WRITE, size, null) mmap(heapchunk_t*) = chunk_memory heapchunk_t*
    { 1 return } (memory_start < null) if
    { 1 return } (chunk_memory < null) if

    [size, memory_start, false] = chunk heapchunk_t

    chunk_memory = chunks::heap
    size / @heapchunk_t = chunks_cap::heap
    1 = nchunks::heap
    
    chunk = *(chunks::heap)

    0 return
} (heap heapinfo_t*, size long) init_heap int

{
    { 1 return } ( nchunks::heap + 1 == chunks_cap::heap) if

    {
        (chunks::heap + i * @heapchunk_t) = Pchunk heapchunk_t*
        *Pchunk = _chunk heapchunk_t
        (chunks::heap + (i + 1) * @heapchunk_t) = Pchunk
        _chunk = *Pchunk
    } (i - 1 = i; i >= index; nchunks::heap - 1 = i int) for

    (chunks::heap + index * @heapchunk_t) = Pchunk
    *chunk = *Pchunk

    nchunks::heap + 1 = nchunks::heap
    0 return
} (heap heapinfo_t*, chunk heapchunk_t*, index long) insert_chunk int

{
    {
        nchunks::heap - 1 = nchunks::heap
        return
    } (index == nchunks::heap - 1) if

    {
        (chunks::heap + (i + 1) * @heapchunk_t) = Pchunk heapchunk_t*
        *Pchunk = _chunk heapchunk_t

        (chunks::heap + i * @heapchunk_t) = Pchunk
        _chunk = *Pchunk
    } (i + 1 = i; i < (nchunks::heap - 1); index = i int) for

    nchunks::heap - 1 = nchunks::heap
    return
} (heap heapinfo_t*, index long) remove_chunk void

{
    (chunks::heap + chunk_index * @heapchunk_t) = chunk heapchunk_t*

    nchunks::heap = new_chunk_index long
    [bytes, start::chunk, false] = new_chunk heapchunk_t

    start::chunk + bytes = start::chunk
    size::chunk - bytes = size::chunk

    {
        null(heapchunk_t*) return
    } ((heap, &new_chunk, chunk_index)insert_chunk) if

    chunk return
} (chunk_index long, heap heapinfo_t*, bytes long) split_chunk heapchunk_t*

{ 
    # nchunks::heap - 1 = chunk_index long
    0 = chunk_index long

    {
        ((chunks::heap) + i * @heapchunk_t) = chunk heapchunk_t*

        { continue } (size::chunk < bytes) if
        { continue } (inuse::chunk) if

        { 
            (i, heap, bytes)split_chunk = chunk
        } (size::chunk > bytes) if

        true = inuse::chunk
        start::chunk return
    } (i + 1 = i; i < nchunks::heap; 0 = i int) for
    # } (i - 1 = i; i >= 0; chunk_index = i int) for

    null return
} (heap heapinfo_t*, bytes long) heap_alloc void*

{
    {
        ((chunks::heap) + i * @heapchunk_t) = chunk heapchunk_t*

        { 
            i return 
        } (start::chunk == ptr) if

    } (i + 1 = i; i < nchunks::heap; 0 = i int) for

    -1 return
} (heap heapinfo_t*, ptr void*) find_chunk long

{
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*

    {
        ((chunks::heap) + (index + 1) * @heapchunk_t) = Rchunk heapchunk_t*

        { 
            size::Rchunk + size::chunk = size::chunk
            (heap, index + 1)remove_chunk
        } ( !inuse::Rchunk ) if

    } (index < nchunks::heap - 1) if

    {
        ((chunks::heap) + (index - 1) * @heapchunk_t) = Lchunk heapchunk_t*

        { 
            start::Lchunk = start::chunk
            size::chunk + size::Lchunk = size::chunk
            (heap, index - 1)remove_chunk
        } ( !inuse::Lchunk ) if

    } (index > 0) if

    return
} (heap heapinfo_t*, index long) merge_chunk void

{
    (heap, ptr)find_chunk = index long
    { return } ( index == -1 ) if
    
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*
    false = inuse::chunk
    (heap, index)merge_chunk

    return
} (heap heapinfo_t*, ptr void*) heap_free void

{
    (heap, buf)find_chunk = index long
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*
    (heap, new_size)heap_alloc = new_buf void*

    size::chunk = size long
    { new_size = size } (size::chunk > new_size) if
    size % 8 = n long
    0 = i int

    {
        *(buf(long*) + i) = *(new_buf(long*) + i)
    } (i + 8 = i; i < size-n && size > 8; i) for

    n - i = n

    { *(buf(int*)   + i) = *(new_buf(int*)   + i); n - 4 = n; i + 4 = i } (n >= 4) if
    { *(buf(short*) + i) = *(new_buf(short*) + i); n - 2 = n; i + 2 = i } (n >= 2) if
    { *(buf(byte*)  + i) = *(new_buf(byte*)  + i); n - 1 = n; i + 1 = i } (n >= 1) if

    (heap, buf)heap_free
    new_buf return
} (heap heapinfo_t*, buf void*, new_size long) heap_realloc void*