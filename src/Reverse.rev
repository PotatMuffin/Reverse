0 = _iota long
4 = PROT_EXEC int
2 = PROT_WRITE int
1 = PROT_READ int
0 = PROT_NONE int
2 = MAP_PRIVATE int
32 = MAP_ANONYMOUS int

256  = S_IRUSR long
128  = S_IWUSR long
32   = S_IRGRP long
16   = S_IWGRP long
4    = S_IROTH long

512 = O_TRUNC  int
64  = O_CREAT  int
1   = O_WRONLY int
0   = O_RDONLY int

0 = LOG_INFO int
1 = LOG_WARN int
2 = LOG_ERROR int

0 = STDIN  int
1 = STDOUT int
2 = STDERR int

0(void*) = null void*
null(heapinfo_t*) = heap heapinfo_t* 

1 = true byte
0 = false byte

(false)iota = TT_EOF     short
(false)iota = TT_PLUS    short
(false)iota = TT_MIN     short
(false)iota = TT_STAR    short
(false)iota = TT_FSLASH  short
(false)iota = TT_PERCENT short
(false)iota = TT_AND     short
(false)iota = TT_OR      short
(false)iota = TT_XOR     short
(false)iota = TT_SHL     short
(false)iota = TT_SHR     short
(false)iota = TT_GTH     short
(false)iota = TT_LTH     short
(false)iota = TT_GTE     short
(false)iota = TT_LTE     short
(false)iota = TT_IS      short
(false)iota = TT_ISNT    short
(false)iota = TT_EQ      short
(false)iota = TT_COMMA   short
(false)iota = TT_INT     short
(false)iota = TT_STR     short
(false)iota = TT_PARENL  short
(false)iota = TT_PARENR  short
(false)iota = TT_BRACKL  short
(false)iota = TT_BRACKR  short
(false)iota = TT_IDENT   short
(false)iota = TT_KEYWORD short
(false)iota = TT_NEWLINE short
(true)iota  = TT_COUNT   short

(false)iota = NODE_ROOT       short
(false)iota = NODE_UNOP       short
(false)iota = NODE_BINOP      short
(false)iota = NODE_INT_LIT    short
(false)iota = NODE_VAR_DEF    short
(false)iota = NODE_VAR_ASSIGN short
(false)iota = NODE_VAR        short
(false)iota = NODE_IF         short
(false)iota = NODE_WHILE      short
(false)iota = NODE_FOR        short
(false)iota = NODE_CONTROL    short
(false)iota = NODE_STR_LIT    short
(false)iota = NODE_FUNC_DEF   short
(false)iota = NODE_FUNC_CALL  short
(false)iota = NODE_RETURN     short
(false)iota = NODE_CAST       short
(false)iota = NODE_PTR_ASSIGN short
(true)iota  = NODE_COUNT      short

(false)iota = IMMVALUE short
(false)iota = REG      short
(false)iota = STR      short
(true)iota  = MEMPOS   short

(false)iota = BUILTIN short
(false)iota = PTR     short
(false)iota = FUNC    short
(true)iota  = VAR     short

"if"       = IF       byte*
"else"     = ELSE     byte*
"while"    = WHILE    byte*
"for"      = FOR      byte*
"continue" = CONTINUE byte*
"break"    = BREAK    byte*
"return"   = RETURN   byte*

"rax"  = _RAX byte*; "eax"  = _EAX byte*;  "ax"   = _AX byte*;   "al"   = _AL byte*
"rbx"  = _RBX byte*; "ebx"  = _EBX byte*;  "bx"   = _BX byte*;   "bl"   = _BL byte*
"rcx"  = _RCX byte*; "ecx"  = _ECX byte*;  "cx"   = _CX byte*;   "cl"   = _CL byte*
"rdx"  = _RDX byte*; "edx"  = _EDX byte*;  "dx"   = _DX byte*;   "dl"   = _DL byte*
"rsi"  = _RSI byte*; "esi"  = _ESI byte*;  "si"   = _SI byte*;   "sil"  = _SIL byte*
"rdi"  = _RDI byte*; "edi"  = _EDI byte*;  "di"   = _DI byte*;   "dil"  = _DIL byte*
"rsp"  = _RSP byte*; "esp"  = _ESP byte*;  "sp"   = _SP byte*;   "spl"  = _SPL byte*
"rbp"  = _RBP byte*; "ebp"  = _EBP byte*;  "bp"   = _BP byte*;   "bpl"  = _BPL byte*
"r8"   = _R8 byte*;  "r8d"  = _R8D byte*;  "r8w"  = _R8W byte*;  "r8b"  = _R8B byte*
"r9"   = _R9 byte*;  "r9d"  = _R9D byte*;  "r9w"  = _R9W byte*;  "r9b"  = _R9B byte*
"r10"  = _R10 byte*; "r10d" = _R10D byte*; "r10w" = _R10W byte*; "r10b" = _R10B byte*
"r11"  = _R11 byte*; "r11d" = _R11D byte*; "r11w" = _R11W byte*; "r11b" = _R11B byte*
"r12"  = _R12 byte*; "r12d" = _R12D byte*; "r12w" = _R12W byte*; "r12b" = _R12B byte*
"r13"  = _R13 byte*; "r13d" = _R13D byte*; "r13w" = _R13W byte*; "r13b" = _R13B byte*
"r14"  = _R14 byte*; "r14d" = _R14D byte*; "r14w" = _R14W byte*; "r14b" = _R14B byte*
"r15"  = _R15 byte*; "r15d" = _R15D byte*; "r15w" = _R15W byte*; "r15b" = _R15B byte*
&_RAX = regs byte**

"qword " = _QWORD byte*; "dword " = _DWORD byte*; "word " = _WORD byte*; "byte " = _BYTE byte*
&_QWORD = sizes byte**

0 = QWORD short
1 = DWORD short
2 = WORD  short
3 = BYTE  short
4 = VOID  short

0  = RAX short
1  = RBX short
2  = RCX short
3  = RDX short
4  = RSI short
5  = RDI short
6  = RSP short
7  = RBP short
8  = R8  short
9  = R9  short
10 = R10 short
11 = R11 short
12 = R12 short
13 = R13 short
14 = R14 short
15 = R15 short

RDI = ARG0 short; RSI = ARG1 short; RDX = ARG2 short; RCX = ARG3 short; R8 = ARG4 short; R9 = ARG5 short
&ARG0 = argRegs short*

Settings {
    source_fn byte*
    output_fn byte*
    memory    long
    debug     byte
} struct

[null(byte*), "out.asm", 16 << 20, 0] = settings Settings
(()get_argc, ()get_argv)main = exit_code int
(exit_code)exit

{
    { 1 return } ((argc, argv, &settings)parse_args != 0) if

    [0(heapchunk_t*),0,0,null] = _heap heapinfo_t
    &_heap = heap

    {   
        (LOG_ERROR, "Could not initialize heap\n")log
        1 return
    } ((&_heap, memory::settings)init_heap != 0) if

    (0, O_RDONLY, source_fn::settings)open = source_fd int

    { 
        (LOG_ERROR, "Source file not found\n")log 
        1 return
    } (source_fd < 0) if

    null(Result*) = res Result*
    (source_fd)read_file = src byte*
    (source_fd)close

    (LOG_INFO, "Tokenizing file\n")log
    [src, [source_fn::settings, 1, 1], 0] = lexer Lexer
    (&lexer)tokenize = res

    { (err::res)print_error; 1 return} (err::res != null) if
    res::res(List*) = tokens List*
    (heap, src)heap_free
    (heap, res(void*))heap_free

    (LOG_INFO, "Parsing file\n")log
    [tokens, 0] = parser Parser
    (&parser, TT_EOF)parse = res

    { (err::res)print_error; 1 return} (err::res != null) if
    res::res(NodeRoot*) = ast NodeRoot*

    { (ast(Node*))display_ast } (debug::settings) if

    (heap, res(void*))heap_free
    (tokens)deconstruct_list
    (heap, tokens(void*))heap_free

    (LOG_INFO, "Validating program\n")log
    [0,0,null(Symbol**), null,0] = table SymbolTable
    (&table, 65536, null(SymbolTable*), false)init_symboltable

    (ast, &table)validate = res
    { (err::res)print_error; 1 return } (err::res != null) if

    (LOG_INFO, "Generating assembly\n")log
    (ast, &table, output_fn::settings)generate = code int
    { 1 return } (code != 0) if
    0 return
} (argc int, argv byte**) main int

{
    false = found_source byte
    false = found_output byte

    {
        (argv + i * @void*) = arg byte**

        {
            true = debug::settings
            continue
        } (("-d", *arg)strcmp) if else
        { 
            0 = num long
            arg + @void* = arg
            
            {
                (LOG_ERROR, "Invalid argument for -m\n")log
                1 return
            } ((*arg, &num)try_parse_int) if

            num << 10 = memory::settings
            i + 1 = i
            continue
        } ( ("-m", *arg)strcmp ) if

        {
            *arg = output_fn::settings
            true = found_output
            continue
        } (!found_output) if else  
        {
            *arg = source_fn::settings
            true = found_source
            continue
        } (!found_source) if

        (*argv)print_usage
        1 return

    } (i + 1 = i; i < argc; 1 = i int) for

    { (*argv)print_usage; 1 return } (!found_source) if

    0 return
} (argc int, argv byte**, settings Settings*) parse_args int

{
    ("Usage: ")print
    (prog)print
    (" <source> [output]\n")print
    ("optional settings:\n")print
    ("  -m <limit>   set the available memory in kilobytes\n")print
    ("  -d           show debug information\n")print
    return
} (prog byte*) print_usage void

Position {
    file byte*
    line int
    column int
} struct

Error {
    msg byte*
    pos Position
} struct

{
    msg::err = str4 byte*; (column::pos::err)itoa = str3 byte*; (line::pos::err)itoa = str2 byte*; file::pos::err = str1 byte*
    ("%:%:%: %\n", &str1, 4)strformat = msg byte*
    (LOG_ERROR, msg)log
    (heap, msg(void*))heap_free
    (heap, str2(void*))heap_free
    (heap, str3(void*))heap_free
    return
} (err Error*) print_error void

Result {
    err Error*
    res void*
} struct

{
    { 
        err::that = err::this
        (heap, that(void*))heap_free
        null return
    } (err::that != null) if

    null(Error*) = err::this
    (heap, that(void*))heap_free
    res::that(void*) return
} (this Result*, that Result*) result_register void*

{
    (heap, @Error)heap_alloc(Error*) = err Error*
    [file::pos, line::pos, column::pos] = pos::err
    msg = msg::err
    err = err::this
    this return
} (this Result*, pos Position*, msg byte*) result_fail Result*

{
    null(Error*) = err::this
    res = res::this
    this return
} (this Result*, res void*) result_success Result*

#####################################################################
# List
#####################################################################

List {
    count int
    capacity int
    items void**
} struct

{
    {
        (items::_list + i * @void*) = Pitem void**
        (heap, *Pitem)heap_free
    } (i + 1 = i; i < count::_list; 0 = i int) for
    (heap, items::_list(void*))heap_free
    return
} (_list List*) deconstruct_list void

{
    {
        capacity::_list*2 = capacity::_list
        (heap, items::_list(void*), capacity::_list * @void*)heap_realloc(void**) = buf void**
        buf = items::_list
    } (count::_list == capacity::_list) if

    (items::_list + count::_list * @void*) = pos void**
    item = *pos 
    count::_list + 1 = count::_list
    return
} (_list List*, item void*) list_append void

{
    0 = count::_list
    8 = capacity::_list
    (heap, 8 * @void*)heap_alloc(void**) = buf void**
    buf = items::_list
    return
} (_list List*) init_list void

#####################################################################
# Lexer
#####################################################################

Token {
    type short
    data long
    pos Position
} struct

{
    null(byte*) = str byte*
    { "keyword"    = str } (type == TT_KEYWORD) if else
    { "identifier" = str } (type == TT_IDENT)   if else
    { "EOF"        = str } (type == TT_EOF)     if else
    { "newline"    = str } (type == TT_NEWLINE) if else
    { "int"        = str } (type == TT_INT)     if else
    { "')'"        = str } (type == TT_PARENR)  if else
    { "'('"        = str } (type == TT_PARENL)  if else 
    { "="          = str } (type == TT_EQ)      if else
    { "'%'"        = str } (type == TT_PERCENT) if else
    { "'/'"        = str } (type == TT_FSLASH)  if else
    { "'*'"        = str } (type == TT_STAR)    if else
    { "'-'"        = str } (type == TT_MIN)     if else
    { "'+'"        = str } (type == TT_PLUS)    if
    str return
} (type short) tt_to_str byte*

{
    -1 = prec byte
    { 5 = prec } (type == TT_PERCENT) if else
    { 5 = prec } (type == TT_FSLASH)  if else
    { 5 = prec } (type == TT_STAR)    if else
    { 4 = prec } (type == TT_MIN)     if else
    { 4 = prec } (type == TT_PLUS)    if else
    { 3 = prec } (type == TT_AND)     if else
    { 3 = prec } (type == TT_OR)      if else
    { 3 = prec } (type == TT_XOR)     if else
    { 3 = prec } (type == TT_SHL)     if else
    { 3 = prec } (type == TT_SHR)     if else
    { 2 = prec } (type == TT_IS)      if else
    { 2 = prec } (type == TT_ISNT)    if else
    { 2 = prec } (type == TT_GTH)     if else
    { 2 = prec } (type == TT_GTE)     if else
    { 2 = prec } (type == TT_LTH)     if else
    { 2 = prec } (type == TT_LTE)     if
    prec return
} (type short) get_prec byte

Lexer {
    src byte*
    pos Position
    index long
} struct

{
    *(src::lexer + index::lexer) = c byte
    index::lexer + 1 = index::lexer
    column::pos::lexer + 1 = column::pos::lexer
    {
        1 = column::pos::lexer
        line::pos::lexer + 1 = line::pos::lexer
    } (c == 10) if
    c return
} (lexer Lexer*) lexer_consume byte

{
    *(src::lexer + index::lexer + offset) = c byte
    c return
} (lexer Lexer*, offset int) lexer_peek byte

{
    false = is_keyword byte
    is_keyword || (str, IF)strcmp       = is_keyword
    is_keyword || (str, ELSE)strcmp     = is_keyword
    is_keyword || (str, WHILE)strcmp    = is_keyword
    is_keyword || (str, FOR)strcmp      = is_keyword
    is_keyword || (str, CONTINUE)strcmp = is_keyword
    is_keyword || (str, BREAK)strcmp    = is_keyword
    is_keyword || (str, RETURN)strcmp   = is_keyword
    is_keyword return
} (str byte*) is_keyword byte

{
    { (LOG_WARN, "Exhaustive handling of token types in 'tokenize'\n")log } (TT_COUNT != 28) if
    
    (heap, @List)heap_alloc(List*) = tokens List*
    (tokens)init_list

    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Error*) = err::res
    null(Token*) = tok Token*
    {
        (lexer, 0)lexer_peek = c byte
        {
            (lexer)lexer_consume
            continue
        } (c == 9 || c == 11 || c == 12 || c == 13 || c == 32) if

        (heap, @Token)heap_alloc(Token*) = tok
        [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::tok
        0 = type::tok
        0 = data::tok

        { 
            0 = n long
            {
                n * 10 = n
                n + (c - '0') = n
                (lexer, 1)lexer_peek = c 
                { break } ('9' < c || c < '0') if
                (lexer)lexer_consume
            } (true) while

            TT_INT = type::tok
            n = data::tok
        } ('9' >= c && c >= '0') if else
        {
            0 = i int
            (lexer, i)lexer_peek = nc byte
            { 
                i + 1 = i
                (lexer, i)lexer_peek = nc
            } ((nc >= 'A' && 'Z' >= nc) || (nc >= 'a' && 'z' >= nc) || ('9' >= nc && nc >= '0') || nc == '_') while

        (heap, i+1)heap_alloc(byte*) = ident byte*
        (src::lexer + index::lexer, ident, i)memcpy
        0 = *(ident + i)
        
        { (lexer)lexer_consume } (i - 1 = i; i > 1; i) for
        TT_IDENT = type::tok
        { TT_KEYWORD = type::tok } ((ident)is_keyword) if

        ident(long) = data::tok
        } ((c >= 'A' && 'Z' >= c) || (c >= 'a' && 'z' >= c) || c == '_') if else
        {
            0 = i
            (lexer, 1)lexer_peek = nc
            {
                (lexer, i+2)lexer_peek = nc
                { (res, &pos::lexer, "string wasnt closed")result_fail return } (nc == 0) if
                i + 1 = i
            } (nc != '"') while
            (lexer)lexer_consume
            (heap, i+1)heap_alloc = string byte*
            (src::lexer + index::lexer, string, i)memcpy
            0 = *(string + i)

            { (lexer)lexer_consume } (i - 1 = i; i > 0; i) for
            TT_STR = type::tok
            string(long) = data::tok
        } (c == '"') if else
        { TT_NEWLINE = type::tok } (c == ';') if else
        { TT_NEWLINE = type::tok } (c == 10 ) if else
        { TT_BRACKL  = type::tok } (c == '{') if else
        { TT_BRACKR  = type::tok } (c == '}') if else
        { TT_PARENL  = type::tok } (c == '(') if else
        { TT_PARENR  = type::tok } (c == ')') if else
        {
            (lexer, 1)lexer_peek = c
            { TT_ISNT = type::tok; (lexer)lexer_consume } (c == '=') if
        } (c == '!') if else
        {
            (lexer, 1)lexer_peek = c
            { TT_IS  = type::tok; (lexer)lexer_consume } (c == '=') if
            { TT_EQ  = type::tok } (type::tok == 0) if
        } (c == '=') if else
        {
            (lexer, 1)lexer_peek = c
            { TT_GTE = type::tok; (lexer)lexer_consume } (c == '=') if else
            { TT_SHR = type::tok; (lexer)lexer_consume } (c == '>') if
            { TT_GTH = type::tok } (type::tok == 0) if
        } (c == '>') if else
        {
            (lexer, 1)lexer_peek = c
            { TT_SHL = type::tok; (lexer)lexer_consume } (c == '<') if else
            { TT_LTE = type::tok; (lexer)lexer_consume } (c == '=') if
            { TT_LTH = type::tok } (type::tok == 0) if
        } (c == '<') if else
        { TT_AND     = type::tok } (c == '&') if else
        { TT_OR      = type::tok } (c == '|') if else
        { TT_XOR     = type::tok } (c == '^') if else
        { TT_PERCENT = type::tok } (c == '%') if else
        { TT_FSLASH  = type::tok } (c == '/') if else
        { TT_STAR    = type::tok } (c == '*') if else
        { TT_MIN     = type::tok } (c == '-') if else 
        { TT_PLUS    = type::tok } (c == '+') if else
        { TT_COMMA   = type::tok } (c == ',') if else
        {
            { (lexer)lexer_consume; (lexer,0)lexer_peek = c } (c != 10 && c != 0) while
            continue
        } (c == '#') if

        {
            (res, &pos::lexer, "Illegal character")result_fail return
        } (type::tok == 0) if 

        (tokens, tok(void*))list_append
        (lexer)lexer_consume
    } ((lexer, 0)lexer_peek) while 

    (heap, @Token)heap_alloc(Token*) = tok 
    [file::pos::lexer, line::pos::lexer, column::pos::lexer] = pos::tok
    TT_EOF = type::tok
    (tokens, tok(void*))list_append

    (res, tokens(void*))result_success return
} (lexer Lexer*) tokenize Result*

#####################################################################
# Parser
#####################################################################

Symbol {
    type short
    name byte*
} struct


SymbolTable {
    size   long
    stack  long
    items  Symbol**
    parent void* # SymbolTable*
    affects_parent byte
} struct

_Type {
    name byte*
    ptr  int
    pos  Position
} struct

_Param {
    name byte*
    type _Type*
    pos  Position
} struct

Node {
    type short
    pos  Position
} struct

NodeRoot {
    super     Node
    children  List
    functions List
    table     SymbolTable*
} struct

{
    (heap, @NodeRoot)heap_alloc(NodeRoot*) = node NodeRoot*
    NODE_ROOT = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    (&children::node)init_list
    (&functions::node)init_list
    null(SymbolTable*) = table::node
    node return
} (pos Position*) create_node_root NodeRoot*

NodeUnop {
    super Node
    node  Node*
    op    short
    type  void* # Type*
} struct

{
    (heap, @NodeUnop)heap_alloc(NodeUnop*) = node NodeUnop*
    NODE_UNOP = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    _node = node::node
    op = op::node
    null = type::node
    node return
} (pos Position*, _node Node*, op short) create_node_unop NodeUnop*

NodeBinop {
    super Node
    left  Node*
    op    short
    right Node*
} struct

{
    (heap, @NodeBinop)heap_alloc(NodeBinop*) = node NodeBinop*
    NODE_BINOP = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    left = left::node
    op = op::node
    right = right::node
    node return
} (pos Position*, left Node*, op short, right Node*) create_node_binop NodeBinop*

NodeIntLit {
    super Node
    val   long
} struct

{
    (heap, @NodeIntLit)heap_alloc(NodeIntLit*) = node NodeIntLit*
    NODE_INT_LIT = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    val = val::node
    node return
} (pos Position*, val long) create_node_int_lit NodeIntLit*

NodeVarDef {
    super Node
    name  byte*
    val   Node*
    type  _Type*
} struct

{
    (heap, @NodeVarDef)heap_alloc(NodeVarDef*) = node NodeVarDef*
    NODE_VAR_DEF = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    val = val::node
    varType = type::node
    node return
} (pos Position*, name byte*, val Node*, varType _Type*) create_node_var_def NodeVarDef*

NodeVarAssign {
    super Node
    name  byte*
    val   Node*
} struct

{
    (heap, @NodeVarAssign)heap_alloc(NodeVarAssign*) = node NodeVarAssign*
    NODE_VAR_ASSIGN = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    val = val::node
    node return
} (pos Position*, name byte*, val Node*) create_node_var_assign NodeVarAssign*

NodeVar {
    super Node
    name byte*
} struct

{
    (heap, @NodeVar)heap_alloc(NodeVar*) = node NodeVar*
    NODE_VAR = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    node return
} (pos Position*, name byte*) create_node_var NodeVar*

NodeIf {
    super     Node
    scope     Node*
    condition Node*
    _else     Node*
} struct

{
    (heap, @NodeIf)heap_alloc(NodeIf*) = node NodeIf*
    NODE_IF = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    condition = condition::node
    null(Node*) = _else::node
    node return
} (pos Position*, scope Node*, condition Node*) create_node_if NodeIf*

NodeWhile {
    super     Node
    scope     Node*
    condition Node*
} struct

{
    (heap, @NodeWhile)heap_alloc(NodeWhile*) = node NodeWhile*
    NODE_WHILE = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    condition = condition::node
    node return
} (pos Position*, scope Node*, condition Node*) create_node_while NodeWhile*

NodeFor {
    super     Node
    scope     Node*
    on_loop   Node*
    condition Node*
    on_entry  Node*
} struct

{
    (heap, @NodeFor)heap_alloc(NodeFor*) = node NodeFor*
    NODE_FOR = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    on_loop = on_loop::node
    condition = condition::node
    on_entry = on_entry::node
    node return
} (pos Position*, scope Node*, on_loop Node*, condition Node*, on_entry Node*) create_node_for NodeFor*

NodeControl {
    super   Node
    keyword byte*
} struct

{
    (heap, @NodeControl)heap_alloc(NodeControl*) = node NodeControl*
    NODE_CONTROL = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    keyword = keyword::node
    node return
} (pos Position*, keyword byte*) create_node_control NodeControl*

NodeStrLit {
    super Node
    str   byte*
} struct

{
    (heap, @NodeStrLit)heap_alloc(NodeStrLit*) = node NodeStrLit*
    NODE_STR_LIT = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    str = str::node
    node return
} (pos Position*, str byte*) create_node_str_lit NodeControl*

NodeFuncDef {
    super   Node
    scope   Node*
    name    byte*
    retType _Type*
    params  List*
} struct

{
    (heap, @NodeFuncDef)heap_alloc(NodeFuncDef*) = node NodeFuncDef*
    NODE_FUNC_DEF = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    scope = scope::node
    name = name::node
    retType = retType::node
    params = params::node
    node return
} (pos Position*, scope Node*, name byte*, retType _Type*, params List*) create_node_func_def NodeFuncDef*

NodeFuncCall {
    super Node
    name byte*
    params List*
} struct

{
    (heap, @NodeFuncCall)heap_alloc(NodeFuncCall*) = node NodeFuncCall*
    NODE_FUNC_CALL = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    name = name::node
    params = params::node
    node return
} (pos Position*, name byte*, params List*) create_node_func_call NodeFuncCall*

NodeReturn {
    super Node
    val   Node*
} struct

{
    (heap, @NodeReturn)heap_alloc(NodeReturn*) = node NodeReturn*
    NODE_RETURN = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    val = val::node
    node return
} (pos Position*, val Node*) create_node_return NodeReturn*

NodeCast {
    super Node
    castee Node*
    cast_type _Type*
} struct

{
    (heap, @NodeCast)heap_alloc(NodeCast*) = node NodeCast*
    NODE_CAST = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    castee = castee::node
    cast_type = cast_type::node
    node return
} (pos Position*, castee Node*, cast_type _Type*) create_node_cast NodeCast*

NodePtrAssign {
    super Node
    value Node*
    ptr   Node*
} struct

{
    (heap, @NodePtrAssign)heap_alloc(NodePtrAssign*) = node NodePtrAssign*
    NODE_PTR_ASSIGN = type::super::node
    [file::pos, line::pos, column::pos] = pos::super::node
    value = value::node
    ptr = ptr::node
    node return
} (pos Position*, value Node*, ptr Node*) create_node_ptr_assign NodePtrAssign*

Parser {
    tokens List*
    index long
} struct

{
    (items::tokens::parser + index::parser * @void*)(Token**) = Ptok Token**
    index::parser + 1 = index::parser
    *Ptok return
} (parser Parser*) parser_consume Token*

{
    (parser, 0)parser_peek = tok Token*
    { 
        (parser)parser_consume 
        tok return
    } (type::tok == type) if

    null(Token*) return
} (parser Parser*, type short) parser_consume_token Token*

{
    (parser, 0)parser_peek = tok Token*
    {  
        (parser)parser_consume
        (parser, 0)parser_peek = tok 
    } (type::tok == type) while
    return
} (parser Parser*, type short) parser_consume_all void

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Error*) = err::res
    (parser)parser_consume = tok Token*

    {
        (expected_type)tt_to_str = type byte*
        ("Expected ", type)strconcat = msg byte*
        (heap, msg(void*))heap_free

        (res, &pos::tok, msg)result_fail return
    } (type::tok != expected_type) if

    tok(void*) = res::res
    res return
} (parser Parser*, expected_type short) parser_expect Result*

{
    (items::tokens::parser + (index::parser + offset) * @void*)(Token**) = Ptok Token**
    *Ptok return
} (parser Parser*, offset int) parser_peek Token*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*
    (&pos::tok)create_node_root = root NodeRoot*

    {
        (parser, TT_NEWLINE)parser_consume_all
        (parser, 0)parser_peek = tok 
        { break } ( type::tok == end ) if

        (res, (parser)parse_stmt)result_register(Node*) = node Node*
        { res return } (err::res != null) if 

        { (&children::root, node(void*))list_append  } else
        { (&functions::root, node(void*))list_append } (type::node == NODE_FUNC_DEF) if

        (parser, 0)parser_peek = tok
        {
            (res, &pos::tok, "Token cannot appear after previous token")result_fail return
        } (type::tok != TT_NEWLINE && type::tok != end) if

        { break } ( type::tok == end ) if
    } (true) while

    (res, root(void*))result_success return
} (parser Parser*, end short) parse Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*

    {
        (parser)parser_consume
        (parser, null(Node*))parse_scope_expr return
    } (type::tok == TT_BRACKL) if 

    (parser)parse_expr return
} (parser Parser*) parse_stmt Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Result*) = result Result*

    (res, (parser, TT_BRACKR)parse)result_register(Node*) = scope Node*
    { res return } (err::res != null) if 
    (parser)parser_consume

    (parser, 0)parser_peek = tok Token*
    {    
        { (res, scope(void*))result_success return } (type::tok != TT_PARENL) if

        1 = parencount int
        1 = i int
        {
            (parser, i)parser_peek = tok
            { parencount + 1 = parencount } (type::tok == TT_PARENL) if
            { parencount - 1 = parencount } (type::tok == TT_PARENR) if
        } (i + 1 = i; parencount > 0; i) for
        (parser, i)parser_peek = tok
        
        {
            (res, &pos::tok, "Expected 'if', 'else', 'for', 'while', or identifier")result_fail return
        } (type::tok != TT_KEYWORD && type::tok != TT_IDENT) if
        {
            (parser, scope, _else)parse_if_expr = result
        } ((data::tok(byte*), IF)strcmp) if else
        {
            (parser, scope)parse_while_expr = result
        } ((data::tok(byte*), WHILE)strcmp) if else
        {
            (parser, scope)parse_for_expr = result
        } ((data::tok(byte*), FOR)strcmp) if else
        {
            (parser, scope)parse_func_expr = result
        } (type::tok == TT_IDENT) if
    } else
    {
        (parser, scope)parse_else_expr = result
    } ( type::tok == TT_KEYWORD && (data::tok(byte*), ELSE)strcmp) if

    (res, result)result_register(Node*) = scope
    { res return } (err::res != null) if

    {
        (res, &pos::tok, "Expected 'if', 'else', 'for', 'while', or identifier")result_fail return
    } (type::scope != NODE_IF && type::scope != NODE_FOR && type::scope != NODE_WHILE && type::scope != NODE_FUNC_DEF) if

    { (heap, data::tok(void*))heap_free } (type::tok != TT_IDENT) if
    (res, scope(void*))result_success return
} (parser Parser*, _else Node*) parse_scope_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume
    (parser, TT_NEWLINE)parser_consume_all
    (parser)parser_consume = tok Token*

    { (res, &pos::tok, "Expected '{'")result_fail return } (type::tok != TT_BRACKL) if

    (res, (parser, scope)parse_scope_expr)result_register(NodeIf*) = node NodeIf*
    { res return } (err::res != null) if

    {
        (res, &pos::super::node, "Expected if statement")result_fail return
    } (type::super::node != NODE_IF) if

    (res, node(void*))result_success return
} (parser Parser*, scope Node*)parse_else_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume

    (res, (parser)parse_expr)result_register(Node*) = condition Node*
    { res return } (err::res != null) if

    (res, (parser, TT_PARENR)parser_expect)result_register
    { res return } (err::res != null) if
    (parser)parser_consume = tok Token*

    (&pos::tok, scope, condition)create_node_if(NodeIf*) = node NodeIf*

    {
        _else = _else::node
    } (_else != null) if

    (parser, 0)parser_peek = tok
    {
        (parser)parser_consume = tok
        (parser, TT_NEWLINE)parser_consume_all
        (parser)parser_consume = tok

        { (res, &pos::tok, "Expected '{'")result_fail return } (type::tok != TT_BRACKL) if
        (res, (parser, node(Node*))parse_scope_expr)result_register(NodeIf*) = node
        { res return } (err::res != null) if

        {
            (res, &pos::super::node, "Expected if statement")result_fail return
        } (type::super::node != NODE_IF) if

        (parser, 0)parser_peek = tok
    } (type::tok == TT_KEYWORD && (data::tok(byte*), ELSE)strcmp) if

    (res, node(void*))result_success return
} (parser Parser*, scope Node*, _else Node*) parse_if_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume

    (res, (parser)parse_expr)result_register(Node*) = condition Node*
    { res return } (err::res != null) if

    (res, (parser, TT_PARENR)parser_expect)result_register
    { res return } (err::res != null) if
    (parser)parser_consume = tok Token*

    (&pos::tok, scope, condition)create_node_while(Node*) = node Node*

    (res, node(void*))result_success return
} (parser Parser*, scope Node*) parse_while_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume
    (res, (parser)parse_expr)result_register(Node*) = on_loop Node*
    { res return } (err::res != null) if
    (res, (parser, TT_NEWLINE)parser_expect)result_register
    { res return } (err::res != null) if

    (res, (parser)parse_expr)result_register(Node*) = condition Node*
    { res return } (err::res != null) if
    (res, (parser, TT_NEWLINE)parser_expect)result_register
    { res return } (err::res != null) if

    (res, (parser)parse_expr)result_register(Node*) = on_entry Node*
    { res return } (err::res != null) if
    (res, (parser, TT_PARENR)parser_expect)result_register
    { res return } (err::res != null) if
    (parser)parser_consume = tok Token*

    (&pos::tok, scope, on_loop, condition, on_entry)create_node_for(Node*) = node Node*
    (res, node(void*))result_success return
} (parser Parser*, scope Node*) parse_for_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume

    (parser, 0)parser_peek = param_name Token*
    null(Token*) = type_name Token*
    null(_Type*) = type _Type* 

    (heap, @List)heap_alloc(List*) = params List*
    (params)init_list

    {
        (parser)parser_consume
        (parser, 0)parser_peek = type_name

        {
            (res, &pos::type_name, "Expected type")result_fail return
        } (type::type_name != TT_IDENT) if
        (res, (parser)parse_type)result_register(_Type*) = type
        { res return } (err::res != null) if

        (heap, @_Param)heap_alloc(_Param*) = param _Param*
        [data::param_name(byte*), type, [file::pos::param_name, line::pos::param_name, column::pos::param_name]] = *param
        (params, param(void*))list_append

        {
            (parser)parser_consume
            (parser, 0)parser_peek = param_name

            {
                (res, &pos::param_name, "Expected identifier")result_fail return
            } (type::param_name != TT_IDENT) if
            (parser)parser_consume

            (parser, 0)parser_peek = type_name
            {
                (res, &pos::type_name, "Expected type")result_fail return
            } (type::type_name != TT_IDENT) if
            (res, (parser)parse_type)result_register(_Type*) = type
            { res return } (err::res != null) if

            (heap, @_Param)heap_alloc(_Param*) = param
            [data::param_name(byte*), type, [file::pos::param_name, line::pos::param_name, column::pos::param_name]] = *param
            (params, param(void*))list_append
        } (type::(parser, 0)parser_peek == TT_COMMA) while
    } (type::param_name == TT_IDENT) if

    (parser)parser_consume = tok Token*
    {
        (res, &pos::tok, "Expected ',', or ')'")result_fail return
    } (type::tok != TT_PARENR) if

    (parser)parser_consume = func_name Token*
    {
        (res, &pos::func_name, "Expected identifier")result_fail return
    } (type::func_name != TT_IDENT) if

    (parser,0)parser_peek = func_type Token*
    {
        (res, &pos::func_type, "Expected type")result_fail return
    } (type::func_type != TT_IDENT) if

    (res, (parser)parse_type)result_register(_Type*) = ret_type _Type*
    { res return } (err::res != null) if

    (&pos::func_name, scope, data::func_name(byte*), ret_type, params)create_node_func_def(Node*) = node Node*

    (res, node(void*))result_success return
} (parser Parser*, scope Node*) parse_func_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser,0)parser_peek = tok Token*

    {
        (&pos::tok, null(Node*))create_node_return = nodeReturn NodeReturn*
        (parser)parser_consume
        (heap, data::tok(void*))heap_free
        (res, nodeReturn(void*))result_success return
    } (type::tok == TT_KEYWORD && (data::tok(byte*), RETURN)strcmp) if

    {
        (&pos::tok, data::tok(byte*))create_node_control = nodeControl NodeControl*
        (parser)parser_consume
        (res, nodeControl(void*))result_success return
    } (type::tok == TT_KEYWORD && ((data::tok(byte*), CONTINUE)strcmp || (data::tok(byte*), BREAK)strcmp)) if

    (res, (parser, 0)parse_bin_expr)result_register(Node*) = expr Node*
    { res return } (err::res != null) if

    (parser,0)parser_peek = tok
    {
        (parser, expr)parse_var_expr return
    } (type::tok == TT_EQ) if

    {
        (&pos::tok, expr)create_node_return = nodeReturn
        (parser)parser_consume
        (heap, data::tok(void*))heap_free
        (res, nodeReturn(void*))result_success return
    } (type::tok == TT_KEYWORD && (data::tok(byte*), RETURN)strcmp) if

    (res, expr(void*))result_success return
} (parser Parser*) parse_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    null(Node*) = node Node*

    (parser)parser_consume = _tok Token*
    (parser,0)parser_peek = tok Token*

    {
        (res, (parser, false)parse_atom)result_register(Node*) = ptr Node*
        (&pos::_tok, value, ptr)create_node_ptr_assign(Node*) = node
        (res, node(void*))result_success return
    } (type::tok == TT_STAR) if
    (parser)parser_consume

    {
        (res, &pos::tok, "Expected identifier")result_fail return
    } (type::tok != TT_IDENT) if

    (parser, 0)parser_peek = varType Token*

    {
        (&pos::_tok, data::tok(byte*), value)create_node_var_assign(Node*) = node
        (res, node(void*))result_success return
    } (type::varType != TT_IDENT) if

    (res, (parser)parse_type)result_register(_Type*) = type _Type*
    { res return } (err::res != null) if

    (&pos::_tok, data::tok(byte*), value, type)create_node_var_def(Node*) = node

    (res, node(void*))result_success return
} (parser Parser*, value Node*) parse_var_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser)parser_consume = typeName Token*
    0 = ptr int

    { 
        ptr + 1 = ptr; (parser)parser_consume 
    } (type::(parser, 0)parser_peek == TT_STAR) while

    (heap, @_Type)heap_alloc(_Type*) = type _Type*
    data::typeName(byte*) = name::type
    ptr = ptr::type
    [file::pos::typeName, line::pos::typeName, column::pos::typeName] = pos::type

    (res, type(void*))result_success return
} (parser Parser*) parse_type Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*

    (res, (parser, true)parse_atom)result_register = left void*
    { res return } (err::res != null) if 

    {

        (parser, 0)parser_peek = op Token*

        (type::op)get_prec = prec byte
        # prec will be -1 if the token type is not an operator
        # therefore the prec of a non operator token type will always be lower than min_prec
        { break } (prec < min_prec) if  
        (parser)parser_consume

        (res, (parser, prec + 1)parse_bin_expr)result_register = right void*
        { res return } (err::res != null) if 

        (&pos::op, left(Node*), type::op, right(Node*))create_node_binop(void*) = left
    } (true) while

    (res, left)result_success return
} (parser Parser*, min_prec byte) parse_bin_expr Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*
    null(Node*) = node Node*

    {
        (parser)parser_consume
        (&pos::tok, data::tok(byte*))create_node_var(Node*) = node
    } (type::tok == TT_IDENT) if else
    {
        (parser)parser_consume
        (res, (parser, false)parse_atom)result_register(Node*) = node
        { res return } (err::res != null) if

        (&pos::tok, node(Node*), type::tok)create_node_unop(Node*) = node
    } (type::tok == TT_MIN || type::tok == TT_STAR || type::tok == TT_AND) if else
    {
        (parser)parser_consume
        0 = i int
        1 = parens int
        { 
            (parser, i)parser_peek = _tok Token*
            { parens + 1 = parens }  (type::_tok == TT_PARENL) if
            { parens - 1 = parens }  (type::_tok == TT_PARENR) if
        } (i + 1 = i; parens > 0; i) for

        {
            (res, (parser, 0)parse_bin_expr)result_register(Node*) = node
            { res return } (err::res != null) if
            (res, (parser, TT_PARENR)parser_expect)result_register
            { res return } (err::res != null) if
        } else
        {
            (res, (parser)parse_func_call)result_register(Node*) = node
            { res return } (err::res != null) if
        } (type::(parser, i)parser_peek == TT_IDENT) if

    } (type::tok == TT_PARENL) if else
    {
        (&pos::tok, data::tok(byte*))create_node_str_lit(Node*) = node
        (parser)parser_consume
    } (type::tok == TT_STR) if else
    { 
        (&pos::tok, data::tok)create_node_int_lit(Node*) = node 
        (parser)parser_consume
    } (type::tok == TT_INT) if

    { 
        (res, &pos::tok, "Expected int, identifier, '-', or '('")result_fail return 
    } (node == null) if

    {
        (parser)parser_consume
        (res, (parser)parse_type)result_register(_Type*) = cast_type _Type*
        { res return } (err::res != null) if

        (parser)parser_consume = tok
        { (res, &pos::tok, "Expected ')'")result_fail } (type::tok != TT_PARENR) if

        (&pos::cast_type, node, cast_type)create_node_cast(Node*) = node
    } (cast == true && type::((parser, 0)parser_peek) == TT_PARENL) if

    (res, node(void*))result_success return
} (parser Parser*, cast byte) parse_atom Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (parser, 0)parser_peek = tok Token*

    (heap, @List)heap_alloc(List*) = params List*
    (params)init_list

    {
        (res, (parser,0)parse_bin_expr)result_register(Node*) = param Node*
        { res return } (err::res != null) if
        (params, param(void*))list_append

        {   
            (parser)parser_consume
            (res, (parser,0)parse_bin_expr)result_register(Node*) = param
            { res return } (err::res != null) if
            (params, param(void*))list_append
        } (type::(parser, 0)parser_peek == TT_COMMA) while

        (parser, 0)parser_peek = tok
        {
            (res, &pos::tok, "Expected ')', or ','")result_fail return
        } (type::tok != TT_PARENR) if
    } (type::tok != TT_PARENR) if
    (parser)parser_consume

    (parser)parser_consume = funcName Token*
    {
        (res, &pos::funcName, "Expected identifier")result_fail return
    } (type::funcName != TT_IDENT) if

    (&pos::funcName, data::funcName(byte*), params)create_node_func_call(Node*) = node Node*
    (res, node(void*))result_success return
} (parser Parser*) parse_func_call Result*

{
    {
        node(NodeUnop*) = nodeUnop NodeUnop*
        ((op::nodeUnop)tt_to_str)print
        (node::nodeUnop(Node*))display_ast
    } (type::node == NODE_UNOP) if else
    {
        node(NodeIntLit*) = nodeIntLit NodeIntLit*
        (val::nodeIntLit)print_num
    } (type::node == NODE_INT_LIT) if else
    { 
        node(NodeBinop*) = nodeBinop NodeBinop*
        ("(")print 
        (left::nodeBinop(Node*))display_ast
        (op::nodeBinop)tt_to_str = type byte*
        (type)print
        (right::nodeBinop(Node*))display_ast
        (")")print 
    } (type::node == NODE_BINOP) if else
    { 
        node(NodeRoot*) = nodeRoot NodeRoot*
        {
            (items::children::(nodeRoot) + i * @void*)(Node**) = Pnode Node**
            *Pnode = _node Node*
            (_node)display_ast
            ("\n")print
        } (i + 1 = i; i < count::children::nodeRoot; 0 = i int) for
    } (type::node == NODE_ROOT) if
    return
} (node Node*) display_ast void

#####################################################################
# Symboltable
#####################################################################

Type {
    super     Symbol
    sizeBytes int
    size      int
} struct

Ptr {
    super   Type 
    ptrType Type*
    ptr     int
} struct

{
    (heap, @Ptr)heap_alloc(Ptr*) = ptr Ptr*
    { 
        ptrType::(type(Ptr*)) = type
        ptr::(type(Ptr*)) + _ptr = _ptr 
    } (type::super::type == PTR) if
    [[[PTR, null(byte*)], 8, QWORD], type, _ptr] = *ptr
    ptr return
} (type Type*, _ptr int) create_ptr Ptr*

{
    { ptrType::ptr return } (ptr::ptr == 1) if
    ptr::ptr - 1 = ptr::ptr
    ptr(Type*) return
} (ptr Ptr*) deref_ptr Type*

Var {
    super    Symbol
    pos      long
    type     Type*
    assigned byte
} struct

Func {
    super   Symbol
    retType Type*
    params  List*
} struct

{
    5381 = hash long
    {
        ((hash << 5) + hash) + c = hash
    } (i + 1 = i; *(str + i) = c byte; 0 = i int) for

    hash return
} (str byte*) hash long

{
    ((a%b)+b)%b return
} (a long, b long) umod long 

{
    size = size::table
    (heap, size * @void*)heap_alloc(Symbol**) = items Symbol**

    {
        0 = stack::table
    } else
    {
        stack::parent = stack::table
    } (parent && !affects_parent) if

    affects_parent = affects_parent::table
    items = items::table 
    (items::table(void*), 0, size::table * @void*)memset
    parent(void*) = parent::table
    return
} (table SymbolTable*, size long, parent SymbolTable*, affects_parent byte) init_symboltable void

{
    (name::symbol)hash = _hash long
    (_hash, size::table)umod = index long
    (items::table + index * @void*) = Psymbol Symbol**
    *Psymbol = _symbol Symbol*
    
    {
        (index + 1)%size::table = index
        (items::table + index * @void*) = Psymbol
        *Psymbol = _symbol
    } (_symbol != null && !(name::_symbol, name::symbol)strcmp) while

    symbol = *Psymbol
    return
} (table SymbolTable*, symbol Symbol*) add_symbol void

{
    (heap, @Var)heap_alloc(Var*) = var Var*
    VAR = type::super::var
    name = name::super::var
    varType = type::var
    assigned = assigned::var

    parent::table(SymbolTable*) = _table SymbolTable*

    {
        stack::_table + sizeBytes::varType = stack::_table
        parent::_table(SymbolTable*) = _table
    } (affects_parent::table && _table != null) while
    stack::table + sizeBytes::varType = stack::table

    -stack::table = pos::var
    (table, var(Symbol*))add_symbol
    return
} (table SymbolTable*, name byte*, varType Type*, assigned byte) add_var void

{
    (heap, @Func)heap_alloc(Func*) = func Func*
    FUNC = type::super::func
    name = name::super::func
    retType = retType::func
    params = params::func
    (table, func(Symbol*))add_symbol
    return
} (table SymbolTable*, name byte*, retType Type*, params List*) add_func void

{
    (heap, @Type)heap_alloc(Type*) = builtin Type*
    BUILTIN = type::super::builtin
    name = name::super::builtin
    size = size::builtin
    sizeBytes = sizeBytes::builtin

    (table, builtin(Symbol*))add_symbol
    return
} (table SymbolTable*, name byte*, size int, sizeBytes int) add_builtin void

{
    (name)hash = _hash long
    (_hash, size::table)umod = index long

    (items::table + index * @void*) = Psymbol Symbol**
    *Psymbol = symbol Symbol*

    {
        (index + 1)%size::table = index
        (items::table + index * @void*) = Psymbol
        *Psymbol = symbol
    } (symbol != null && !(name, name::symbol)strcmp) while

    {
        (parent::table(SymbolTable*), name, true)get_symbol return
    } (check_parent && parent::table != null && symbol == null) if

    symbol return
} (table SymbolTable*, name byte*, check_parent byte) get_symbol Symbol*

#####################################################################
# Validator
#####################################################################

ValContext {
    table   SymbolTable*
    retType Type*
    in_loop byte
    pass    byte
} struct

{
    (table, "long", QWORD, 8)add_builtin
    (table, "int",  DWORD, 4)add_builtin
    (table, "short", WORD, 2)add_builtin
    (table, "byte",  BYTE, 1)add_builtin
    (table, "void",  VOID, 0)add_builtin

    table = table::node
    [table, null(Type*), false, 0] = ctx ValContext
    (node(Node*),&ctx)valvisit = res Result*
    res return
} (node NodeRoot*, table SymbolTable*) validate Result*

{
    (table, name::type, true)get_symbol = symbol Symbol*

    {
        null(Type*) return
    } (symbol == null || type::symbol != BUILTIN) if

    {
        (symbol(Type*), ptr::type)create_ptr(Symbol*) = symbol
    } (ptr::type) if

    symbol(Type*) return
} (table SymbolTable*, type _Type*) get_type Type*

{
    { false return } (type::super::this != type::super::that) if

    {
        ptr::(this(Ptr*)) == ptr::(that(Ptr*)) && (ptrType::(this(Ptr*)), ptrType::(that(Ptr*)))type_equals return
    } (type::super::this == PTR) if

    true return
} (this Type*, that Type*) type_equals byte 

{
    { (node(NodePtrAssign*),ctx)valvisit_NodePtrAssign return } (type::node == NODE_PTR_ASSIGN) if else
    { (node(NodeCast*),ctx)valvisit_NodeCast           return } (type::node == NODE_CAST)       if else
    { (node(NodeReturn*),ctx)valvisit_NodeReturn       return } (type::node == NODE_RETURN)     if else
    { (node(NodeFuncCall*),ctx)valvisit_NodeFuncCall   return } (type::node == NODE_FUNC_CALL)  if else
    { (node(NodeFuncDef*),ctx)valvisit_NodeFuncDef     return } (type::node == NODE_FUNC_DEF)   if else
    { (node(NodeStrLit*),ctx)valvisit_NodeStrLit       return } (type::node == NODE_STR_LIT)    if else
    { (node(NodeControl*),ctx)valvisit_NodeControl     return } (type::node == NODE_CONTROL)    if else
    { (node(NodeFor*),ctx)valvisit_NodeFor             return } (type::node == NODE_FOR)        if else
    { (node(NodeWhile*),ctx)valvisit_NodeWhile         return } (type::node == NODE_WHILE)      if else
    { (node(NodeIf*),ctx)valvisit_NodeIf               return } (type::node == NODE_IF)         if else
    { (node(NodeVar*),ctx)valvisit_NodeVar             return } (type::node == NODE_VAR)        if else
    { (node(NodeVarAssign*),ctx)valvisit_NodeVarAssign return } (type::node == NODE_VAR_ASSIGN) if else
    { (node(NodeVarDef*),ctx)valvisit_NodeVarDef       return } (type::node == NODE_VAR_DEF)    if else
    { (node(NodeUnop*),ctx)valvisit_NodeUnop           return } (type::node == NODE_UNOP)       if else
    { (node(NodeIntLit*),ctx)valvisit_NodeIntLit       return } (type::node == NODE_INT_LIT)    if else
    { (node(NodeBinop*),ctx)valvisit_NodeBinop         return } (type::node == NODE_BINOP)      if else
    { (node(NodeRoot*),ctx)valvisit_NodeRoot           return } (type::node == NODE_ROOT)       if
    null(Result*) return
} (node Node*, ctx ValContext*) valvisit Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    {
        (heap, @SymbolTable)heap_alloc(SymbolTable*) = table SymbolTable*
        (table, 128, table::ctx, true)init_symboltable
        table = table::node
    } (table::node == null) if

    [table::node, retType::ctx, in_loop::ctx, 0] = _ctx ValContext
    0 = i int
    null(Node**) = Pnode Node**

    {
        {
            n = pass::_ctx
            (items::functions::node + i * @void*)(Node**) = Pnode 
            (res, (*Pnode, &_ctx)valvisit)result_register
            { res return } (err::res != null) if
        } (i + 1 = i; i < count::functions::node; 0 = i) for
    } (n + 1 = n; n < 2; 0 = n int) for

    {
        (items::children::node + i * @void*)(Node**) = Pnode

        (res, (*Pnode, &_ctx)valvisit)result_register
        { res return } (err::res != null) if
    } (i + 1 = i; i < count::children::node; 0 = i) for

    (res, null)result_success return
} (node NodeRoot*, ctx ValContext*) valvisit_NodeRoot Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (res, (left::node, ctx)valvisit)result_register(Type*) = leftType Type*
    {res return } (err::res != null) if

    (res, (right::node, ctx)valvisit)result_register(Type*) = rightType Type*
    {res return } (err::res != null) if

    (res, leftType(void*))result_success return
} (node NodeBinop*, ctx ValContext*) valvisit_NodeBinop Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (res, (table::ctx, "long", true)get_symbol(void*))result_success return
} (node NodeIntLit*, ctx ValContext*) valvisit_NodeIntLit Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    
    (res, (node::node, ctx)valvisit)result_register(Type*) = type Type*
    {res return } (err::res != null) if

    {
        {
            (res, &pos::super::node, "Can only derefence a pointer")result_fail return
        } (type::super::type != PTR) if
        (type(Ptr*))deref_ptr = type
        type(void*) = type::node
        (res, type(void*))result_success return
    } (op::node == TT_STAR) if else
    {
        {
            (res, &pos::super::node, "Can only take a pointer to a variable")result_fail return 
        } (type::node::node != NODE_VAR) if
        (res, (type, 1)create_ptr(void*))result_success return
    } (op::node == TT_AND) if

    (res, type(void*))result_success return
} (node NodeUnop*, ctx ValContext*) valvisit_NodeUnop Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (table::ctx, name::node, false)get_symbol = symbol Symbol*
    
    (res, (val::node, ctx)valvisit)result_register(Type*) = valType Type*
    {res return } (err::res != null) if

    { 
        name::node = name byte*
        (res, &pos::super::node, ("'%' is already defined", &name, 1)strformat)result_fail return
    } (symbol != null) if

    (table::ctx, type::node)get_type(Type*) = varType Type*

    {
        name::type::node = type byte*
        (res, &pos::type::node, ("'%' is not a type", &type, 1)strformat)result_fail return
    } (varType == null) if

    {
        (res, &pos::super::node, "Cannot define a variable with type void")result_fail return
    } (size::varType == VOID) if

    {
        (res, &pos::super::node, "Type mismatch")result_fail return
    } (!(varType, valType)type_equals) if

    (table::ctx, name::node, varType, false)add_var
    (heap, name::type::node(void*))heap_free
    (heap, type::node(void*))heap_free
    (res, varType(void*))result_success return
} (node NodeVarDef*, ctx ValContext*) valvisit_NodeVarDef Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (table::ctx, name::node, true)get_symbol(Var*) = var Var*

    {
        (res, &pos::super::node, ("'%' is not a variable", &name::node, 1)strformat)result_fail return
    } (type::super::var != VAR) if

    (res, (val::node, ctx)valvisit)result_register(Type*) = valType Type*
    {res return } (err::res != null) if

    { 
        (res, &pos::super::node, ("'%' is not defined", &name::node, 1)strformat)result_fail return
    } (var == null) if

    type::var = varType Type*

    {
        (res, &pos::super::node, "Type mismatch")result_fail return
    } (!(varType, valType)type_equals) if

    (res, varType(void*))result_success return
} (node NodeVarAssign*, ctx ValContext*) valvisit_NodeVarAssign Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (table::ctx, name::node, true)get_symbol(Var*) = var Var*

    { 
        (res, &pos::super::node, ("'%' is not defined", &name::node, 1)strformat)result_fail return
    } (var == null) if

    {
        (res, &pos::super::node, ("'%' is not a variable", &name::node, 1)strformat)result_fail return
    } (type::super::var != VAR) if

    (res, type::var(void*))result_success return
} (node NodeVar*, ctx ValContext*) valvisit_NodeVar Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (heap, @SymbolTable)heap_alloc(SymbolTable*) = table SymbolTable*
    (table, 128, table::ctx, true)init_symboltable
    table = table::(scope::node(NodeRoot*))
    [table, retType::ctx, true, 0] = _ctx ValContext

    (res, (condition::node, ctx)valvisit)result_register
    { res return } (err::res != null) if

    (res, (scope::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if

    {
        (res, (_else::node, ctx)valvisit)result_register
        { res return } (err::res != null) if
    } (_else::node != null) if

    (res, null)result_success return
} (node NodeIf*, ctx ValContext*) valvisit_NodeIf Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (heap, @SymbolTable)heap_alloc(SymbolTable*) = table SymbolTable*
    (table, 128, table::ctx, true)init_symboltable
    table = table::(scope::node(NodeRoot*))
    [table, retType::ctx, true, 0] = _ctx ValContext

    (res, (condition::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if

    (res, (scope::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if
    
    (res, null)result_success return
} (node NodeWhile*, ctx ValContext*) valvisit_NodeWhile Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 

    (heap, @SymbolTable)heap_alloc(SymbolTable*) = table SymbolTable*
    (table, 128, table::ctx, true)init_symboltable
    table = table::(scope::node(NodeRoot*))
    [table, retType::ctx, true, 0] = _ctx ValContext

    (res, (on_entry::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if

    (res, (scope::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if

    (res, (condition::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if

    (res, (on_loop::node, &_ctx)valvisit)result_register
    { res return } (err::res != null) if

    (res, null)result_success return
} (node NodeFor*, ctx ValContext*) valvisit_NodeFor Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    (table::ctx, "byte", true)get_symbol(Type*) = type Type*
    (type, 1)create_ptr(Type*) = type
    (res, type(void*))result_success return
} (node NodeStrLit*, ctx ValContext*) valvisit_NodeStrLit Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result* 
    {
        (res, &pos::super::node, ("Cannot % outside of a loop", &keyword::node, 1)strformat)result_fail return
    } (!in_loop::ctx) if
    (res, null)result_success return
} (node NodeControl*, ctx ValContext*) valvisit_NodeControl Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (table::ctx, name::node, true)get_symbol(Func*) = func Func*

    {
        {
            (res, &pos::super::node, ("'%' is already defined", &name::node, 1)strformat)result_fail return
        } (func != null) if

        (heap, @SymbolTable)heap_alloc(SymbolTable*) = table SymbolTable*
        (table, 256, table::ctx, false)init_symboltable
        table = table::(scope::node(NodeRoot*))

        (heap, @List)heap_alloc(List*) = paramTypes List*
        (paramTypes)init_list

        {
            (items::params::node + i * @void*)(_Param**) = Pparam _Param**
            *Pparam = param _Param*

            (table, name::param, false)get_symbol = symbol Symbol*

            {
                (res, &pos::param, ("'%' is already defined", &name::param, 1)strformat)result_fail return
            } (symbol != null) if

            (table::ctx, type::param)get_type = paramType Type*

            (table, name::param, paramType, true)add_var
            (paramTypes, paramType(void*))list_append
        } (i + 1 = i; i < count::params::node; 0 = i int) for
        
        (table::ctx, retType::node)get_type = retType Type*
        (table::ctx, name::node, retType, paramTypes)add_func
    } else
    {
        [table::(scope::node(NodeRoot*)), retType::func, false, 0] = _ctx ValContext
        (res, (scope::node, &_ctx)valvisit)result_register
        { res return } (err::res != null) if
    } (pass::ctx == 1) if
    (res, null)result_success return
} (node NodeFuncDef*, ctx ValContext*) valvisit_NodeFuncDef Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (table::ctx, name::node, true)get_symbol(Func*) = func Func*

    { 
        (res, &pos::super::node, ("'%' is not defined", &name::node, 1)strformat)result_fail return
    } (func == null) if

    {
        (res, &pos::super::node, ("'%' is not a function", &name::node, 1)strformat)result_fail return
    } (type::super::func != FUNC) if

    {
        (count::params::node)itoa = str3 byte*; (count::params::func)itoa = str2 byte*; name::node = str1 byte*
        (res, &pos::super::node, ("Function '%' expects % parameters but got %", &str1, 3)strformat)result_fail return
    } (count::params::node != count::params::func) if

    {
        (items::params::func + i * @void*)(Type**) = Ptype Type**
        *Ptype = expectedType Type*

        (items::params::node + i * @void*)(Node**) = Pparam Node**
        *Pparam = param Node*

        (res, (param, ctx)valvisit)result_register(Type*) = paramType Type*
        { res return } (err::res != null) if 
        
        {
            (count::params::func-i-1)itoa = str1
            (res, &pos::param, ("Type mismatch with parameter %", &str1, 1)strformat)result_fail return
        } (!(expectedType, paramType)type_equals) if

        { (heap, paramType(void*))heap_free } (type::super::paramType == PTR) if
    } (i + 1 = i; i < count::params::func; 0 = i int) for

    (res, retType::func(void*))result_success return
} (node NodeFuncCall*, ctx ValContext*) valvisit_NodeFuncCall Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    {
        (res, &pos::super::node, "Cannot return outside of a function")result_fail return
    } (retType::ctx == null) if

    {
        (res, &pos::super::node, "Return value was provided in a function that returns void")result_fail return
    } (size::retType::ctx == VOID && val::node != null) if

    {
        (res, &pos::super::node, "No return value was provided in a function that returns non-void")result_fail return
    } (size::retType::ctx != VOID && val::node == null) if

    (res, null)result_success return
} (node NodeReturn*, ctx ValContext*) valvisit_NodeReturn Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (table::ctx, cast_type::node)get_type = cast_type Type*
    
    { (res, &pos::cast_type::node, ("'%' is not a type", &name::cast_type::node, 1)strformat)result_fail return } (cast_type == null) if

    (res, cast_type(void*))result_success return
} (node NodeCast*, ctx ValContext*) valvisit_NodeCast Result*

{
    (heap, @Result)heap_alloc(Result*) = res Result*
    (res, (ptr::node, ctx)valvisit)result_register(Type*) = ptrType Type*
    (res, (value::node, ctx)valvisit)result_register(Type*) = valueType Type*

    {
        (res, &pos::super::node, "Type mismatch")result_fail
    } (!(ptrType, valueType)type_equals) if
    (res, ptrType(void*))result_success return
} (node NodePtrAssign*, ctx ValContext*) valvisit_NodePtrAssign Result*

#####################################################################
# Generator
#####################################################################

Value {
    type short
} struct

Reg {
    super Value
    reg   short
    size  short
} struct

{
    (heap, @Reg)heap_alloc(Reg*) = reg Reg*
    REG = type::super::reg
    _reg = reg::reg
    size = size::reg
    reg return
} (_reg short, size short) create_reg Reg*

Mempos {
    super  Value
    reg    short
    size   short
    offset int
} struct

{
    (heap, @Mempos)heap_alloc(Mempos*) = mempos Mempos*
    MEMPOS = type::super::mempos
    reg = reg::mempos
    size = size::mempos
    offset = offset::mempos
    mempos return
} (reg short, size short, offset long) create_mempos Mempos*

{
    (table, name, true)get_symbol(Var*) = symbol Var*
    { null(Mempos*) return } (type::super::symbol != VAR) if

    { 
        parent::table(SymbolTable*) = table
        (table, name, false)get_symbol(Var*) = symbol
    } (symbol == null || !assigned::symbol) while

    (RBP, size::type::symbol, pos::symbol)create_mempos return
} (table SymbolTable*, name byte*) get_var_pos Mempos*

ImmValue {
    super Value
    val   long
} struct

{
    (heap, @ImmValue)heap_alloc(ImmValue*) = immvalue ImmValue*
    IMMVALUE = type::super::immvalue
    value = val::immvalue
    immvalue return
} (value long) create_immvalue ImmValue*

Str {
    super Value
    val   long
} struct

{
    (heap, @Str)heap_alloc(Str*) = str Str*
    STR = type::super::str
    n = val::str
    str return
} (n long) create_str Str*

{   
    null(byte*) = str byte*
    {
        value(Str*) = _str Str*
        (val::_str)itoa = nStr byte*
        ("string%", &nStr, 1)strformat = str
        (heap, nStr(void*))heap_free
    } (type::value == STR) if else
    {
        value(ImmValue*) = immvalue ImmValue*
        (val::immvalue)itoa = str
    } (type::value == IMMVALUE) if else
    {
        value(Mempos*) = mempos Mempos*
        (sizes - size::mempos * @void*) = PSize byte**
        *PSize = sizeStr byte*
        (regs - reg::mempos*4 * @void*) = PReg byte**
        *PReg = regStr byte*
        "+" = sign byte*
        { "-" = sign; -offset::mempos = offset::mempos } (offset::mempos < 0) if
        (offset::mempos)itoa = offsetStr byte*

        offsetStr = str4 byte*; sign = str3 byte*; *PReg = str2 byte*; *PSize = str1 byte*
        ("%[%%%]", &str1, 4)strformat = str
        (heap, offsetStr(void*))heap_free
    } (type::value == MEMPOS) if else
    {
        value(Reg*) = reg Reg*
        reg::reg*4 + size::reg = index int
        (regs - index * @void*)(byte**) = PStr byte**
        *PStr = str
    } (type::value == REG) if

    str return
} (value Value*) value_to_str byte*

{
    true = is_equal byte
    
    (type::val1 == type::val2) = is_equal
    { is_equal return } (!is_equal) if

    (val1)value_to_str = val1Str byte*
    (val2)value_to_str = val2Str byte*

    (val1Str, val2Str)strcmp = is_equal

    (heap, val1Str(void*))heap_free
    (heap, val2Str(void*))heap_free
    is_equal return
} (val1 Value*, val2 Value*) value_equals byte

{
    (heap, value(void*))heap_free
    return
} (value Value*) destroy void

GenContext {
    table       SymbolTable*
    breaklbl    byte*
    continuelbl byte*
    ifEndlbl    byte*
    strbuf      List*
} struct

{
    false = _uses_reg byte
    {
       _uses_reg || (reg::reg == RAX && lhs)  = _uses_reg
       _uses_reg || (reg::reg == RDI && !lhs) = _uses_reg 
    } (type::node == NODE_UNOP) if else
    {
        node(NodeBinop*) = nodeBinop NodeBinop*
        _uses_reg || (left::nodeBinop,  true,  reg)uses_reg = _uses_reg
        _uses_reg || (right::nodeBinop, false, reg)uses_reg = _uses_reg

        _uses_reg || reg::reg == RCX = _uses_reg 
        _uses_reg || ((op::nodeBinop == TT_FSLASH || op::nodeBinop == TT_PERCENT) && reg::reg == RDX) = _uses_reg 
        _uses_reg || (!lhs && reg::reg == RDI) = _uses_reg 
        _uses_reg || (lhs  && reg::reg == RAX) = _uses_reg
        _uses_reg || reg::reg == RCX = _uses_reg
    } (type::node == NODE_BINOP) if
    _uses_reg return
} (node Node*, lhs byte, reg Reg*) uses_reg byte 

{
    {
        true return
    } (type::node == NODE_INT_LIT) if

    {
        (left::(node(NodeBinop*)))returns_immValue = left byte
        (right::(node(NodeBinop*)))returns_immValue = right byte
        left && right return
    } (type::node == NODE_BINOP) if

    {
        (node::(node(NodeUnop*)))returns_immValue = n byte
        n return
    } (type::node == NODE_UNOP) if
    false return
} (node Node*) returns_immValue byte

{
    0 = value long
    { val::arg1 >= val::arg2 = value } (op == TT_GTE)     if else
    { val::arg1 > val::arg2 = value  } (op == TT_GTH)     if else
    { val::arg1 <= val::arg2 = value } (op == TT_LTE)     if else
    { val::arg1 < val::arg2 = value  } (op == TT_LTH)     if else
    { val::arg1 == val::arg2 = value } (op == TT_IS)      if else
    { val::arg1 != val::arg2 = value } (op == TT_ISNT)    if else
    { val::arg1 + val::arg2 = value  } (op == TT_AND)     if else
    { val::arg1 - val::arg2 = value  } (op == TT_MIN)     if else
    { val::arg1 * val::arg2 = value  } (op == TT_STAR)    if else
    { val::arg1 + val::arg2 = value  } (op == TT_PLUS)    if else
    { val::arg1 / val::arg2 = value  } (op == TT_FSLASH)  if else
    { val::arg1 % val::arg2 = value  } (op == TT_PERCENT) if else
    { val::arg1 | val::arg2 = value  } (op == TT_OR)      if else
    { val::arg1 ^ val::arg2 = value  } (op == TT_XOR)     if else
    { val::arg1 << val::arg2 = value } (op == TT_SHL)     if else
    { val::arg1 >> val::arg2 = value } (op == TT_SHR)     if
    value = val::arg1
    return
} (arg1 ImmValue*, arg2 ImmValue*, op short)calculate_binexpr void

{
    (heap, @FileBuffer)heap_alloc(FileBuffer*) = fbuf FileBuffer*
    (fbuf, fn, 256 << 10)open_file_buffer = code int

    (heap, @List)heap_alloc(List*) = strbuf List*
    (strbuf)init_list

    { (LOG_ERROR, "Could not open output file\n")log; 1 return } (code == 1) if
    { (LOG_ERROR, "Could not allocate file buffer\n")log; 1 return } (code == 2) if

    (fbuf, "format ELF64 executable\nsegment readable executable\nentry $\n")write_file_buffer
    (fbuf, "mov rbp,rsp\n")write_file_buffer

    [table, null(byte*), null(byte*), null(byte*), strbuf] = ctx GenContext
    (ast(Node*), true, &ctx, fbuf)visit

    (fbuf, "segment readable writable\n")write_file_buffer
    {
        (i)itoa = str1 byte*
        (fbuf, "string% db ", &str1, 1)write_file_bufferf
        (heap, str1(void*))heap_free
        (items::strbuf + i * @void*)(byte**) = Pstr byte**
        *Pstr = str byte*
        (str)strlen+1 = len int

        {
            (*(str + j))itoa = str1
            (fbuf, str1)write_file_buffer
            {
                (fbuf, "\n")write_file_buffer
            } else
            { 
                (fbuf, ",")write_file_buffer
            } (*(str + j)) if
            (heap, str1(void*))heap_free
        } (j + 1 = j; j < len; 0 = j int) for
    } (i + 1 = i; i < count::strbuf; 0 = i int) for

    (fbuf)close_file_buffer
    (strbuf)deconstruct_list
    (heap, strbuf(void*))heap_free
    (heap, fbuf(void*))heap_free
    (heap, items::table(void*))heap_free
    0 return
} (ast NodeRoot*, table SymbolTable*, fn byte*) generate int

{
    null(Value*) = value Value*
    { (node(NodePtrAssign*),ctx,fbuf)visit_NodePtrAssign = value } (type::node == NODE_PTR_ASSIGN) if else
    { (node(NodeCast*),ctx,fbuf)visit_NodeCast           = value } (type::node == NODE_CAST)       if else
    { (node(NodeReturn*),ctx,fbuf)visit_NodeReturn       = value } (type::node == NODE_RETURN)     if else
    { (node(NodeFuncCall*),ctx,fbuf)visit_NodeFuncCall   = value } (type::node == NODE_FUNC_CALL)  if else
    { (node(NodeFuncDef*),ctx,fbuf)visit_NodeFuncDef     = value } (type::node == NODE_FUNC_DEF)   if else
    { (node(NodeStrLit*),ctx,fbuf)visit_NodeStrLit       = value } (type::node == NODE_STR_LIT)    if else
    { (node(NodeControl*),ctx,fbuf)visit_NodeControl     = value } (type::node == NODE_CONTROL)    if else
    { (node(NodeFor*),ctx,fbuf)visit_NodeFor             = value } (type::node == NODE_FOR)        if else
    { (node(NodeWhile*),ctx,fbuf)visit_NodeWhile         = value } (type::node == NODE_WHILE)      if else
    { (node(NodeIf*),ctx,fbuf)visit_NodeIf               = value } (type::node == NODE_IF)         if else
    { (node(NodeVar*),ctx,fbuf)visit_NodeVar             = value } (type::node == NODE_VAR)        if else
    { (node(NodeVarAssign*),ctx,fbuf)visit_NodeVarAssign = value } (type::node == NODE_VAR_ASSIGN) if else
    { (node(NodeVarDef*),ctx,fbuf)visit_NodeVarDef       = value } (type::node == NODE_VAR_DEF)    if else
    { (node(NodeUnop*),lhs,ctx,fbuf)visit_NodeUnop       = value } (type::node == NODE_UNOP)       if else
    { (node(NodeIntLit*),ctx,fbuf)visit_NodeIntLit       = value } (type::node == NODE_INT_LIT)    if else
    { (node(NodeBinop*),lhs,ctx,fbuf)visit_NodeBinop     = value } (type::node == NODE_BINOP)      if else
    { (node(NodeRoot*),ctx,fbuf)visit_NodeRoot           = value } (type::node == NODE_ROOT)       if
    (heap, node(void*))heap_free
    value return
} (node Node*, lhs byte, ctx GenContext*, fbuf FileBuffer*) visit Value*

{
    0 = i int
    null(Node**) = Pnode Node**

    [table::node, breaklbl::ctx, continuelbl::ctx, null(byte*), strbuf::ctx] = _ctx GenContext

    {
        (LOG_WARN, "Scope does not contain a symboltable\n")log
        table::ctx = table::_ctx
    } (table::node == null) if

    {
        (items::children::node + i * @void*)(Node**) = Pnode
        (*Pnode, true, &_ctx, fbuf)visit = value Value*
        { (value)destroy } (value != null) if
    } (i + 1 = i; i < count::children::node; 0 = i) for

    {
        (fbuf, "mov rdi,0\nmov rax,60\nsyscall\n")write_file_buffer
    } (parent::table::node == null) if

    {
        (items::functions::node + i * @void*)(Node**) = Pnode
        (*Pnode, true, &_ctx, fbuf)visit
    } (i + 1 = i; i < count::functions::node; 0 = i) for

    null(Value*) return
} (node NodeRoot*, ctx GenContext*, fbuf FileBuffer*) visit_NodeRoot Value*

{
    (value::node, true, ctx, fbuf)visit = value Value*
    (ptr::node, false, ctx, fbuf)visit = ptr Value*
    (ptr, value, fbuf)move
    (heap, ptr(void*))heap_free
    value return
} (node NodePtrAssign*, ctx GenContext*, fbuf FileBuffer*)visit_NodePtrAssign Value*

{
    (castee::node, true, ctx, fbuf)visit = value Value*
    value return
} (node NodeCast*, ctx GenContext*, fbuf FileBuffer*)visit_NodeCast Value*

{
    {
        (val::node, true, ctx, fbuf)visit = returnValue Value*

        QWORD = regSize short
        {
            size::(returnValue(Reg*)) = regSize
        } (type::returnValue == REG || type::returnValue == MEMPOS) if

        (RAX, regSize)create_reg = reg Reg*
        (reg(Value*), returnValue, fbuf)move

        (heap, reg(void*))heap_free
        (heap, returnValue(void*))heap_free
    } (val::node != null) if

    (fbuf, "leave\nret\n")write_file_buffer
    null(Value*) return
} (node NodeReturn*, ctx GenContext*, fbuf FileBuffer*)visit_NodeReturn Value*

{
    (table::ctx, name::node, true)get_symbol(Func*) = func Func*
    count::params::node-6 = stackParams int

    null(Node**) = Pnode Node**
    null(Node*) = _node Node*
    null(Value*) = src Value*

    0 = i int
    {
        (items::params::node + i * @void*)(Node**) = Pnode
        *Pnode = _node

        (_node, true, ctx, fbuf)visit = src
        (src, fbuf)push
    } (i + 1 = i; i < stackParams; i) for

    {
        (items::params::func + i * @void*)(Type**) = Ptype Type**
        *Ptype = paramType Type*

        (items::params::node + i * @void*)(Node**) = Pnode
        *Pnode = _node

        (_node, true, ctx, fbuf)visit = src
        (count::params::node-i-1)*@short = argOffset int
        (*(argRegs - argOffset), size::paramType)create_reg = dest Reg*
        (dest(Value*), src, fbuf)move
        (heap, src(void*))heap_free
        (heap, dest(void*))heap_free
    } (i - 1 = i; i >= stackParams && i >= 0; count::params::node-1 = i) for
    (fbuf, "call func_%\n", &name::node, 1)write_file_bufferf
    
    
    {
        (stackParams*8)itoa = str byte*
        (fbuf, "add rsp,%\n", &str, 1)write_file_bufferf
    } (stackParams > 0) if

    (heap, str(void*))heap_free
    (heap, name::node(void*))heap_free
    (heap, items::params::node(void*))heap_free
    (heap, params::node(void*))heap_free
    (RAX, size::retType::func)create_reg(Value*) return
} (node NodeFuncCall*, ctx GenContext*, fbuf FileBuffer*)visit_NodeFuncCall Value*

{
    (table::ctx, name::node, true)get_symbol(Func*) = func Func*
    (fbuf, "func_%:\n", &name::node, 1)write_file_bufferf
    
    table::(scope::node(NodeRoot*)) = table SymbolTable*
    stack::table = stackSize long
    (stackSize)itoa = stackSizeStr byte*

    (fbuf, "push rbp\nmov rbp,rsp\nsub rsp,%\n", &stackSizeStr, 1)write_file_bufferf
    (heap, stackSizeStr(void*))heap_free

    count::params::node-6 = stackParams int
    {
        (items::params::node + i * @void*)(_Param**) = Pparam _Param**
        *Pparam = param _Param*
        (table, name::param)get_var_pos = dest Mempos*
        null(Value*) = src Value*
        (count::params::node-i-1)*@short = argOffset int

        {
            (*(argRegs - argOffset), size::dest)create_reg(Value*) = src
        } else
        {
            (RBP, QWORD,(stackParams - i)*8+8)create_mempos(Value*) = src
        } (count::params::node - i > 6) if
        (dest(Value*), src, fbuf)move

        (heap, dest(void*))heap_free
        (heap, src(void*))heap_free
    } (i - 1 = i; i >= 0; count::params::node-1 = i int) for
    
    (scope::node, true, ctx, fbuf)visit
    (fbuf, "leave\nret\n")write_file_buffer

    null(Value*) return
} (node NodeFuncDef*, ctx GenContext*, fbuf FileBuffer*)visit_NodeFuncDef Value*

{
    (count::strbuf::ctx)create_str = str Str*
    (strbuf::ctx, str::node(void*))list_append
    str(Value*) return
} (node NodeStrLit*, ctx GenContext*, fbuf FileBuffer*) visit_NodeStrLit Value*

{
    {
        (fbuf, "jmp L%\n", &breaklbl::ctx, 1)write_file_bufferf
    } ((keyword::node, BREAK)strcmp) if else
    {
        (fbuf, "jmp L%\n", &continuelbl::ctx, 1)write_file_bufferf
    } ((keyword::node, CONTINUE)strcmp) if
    (heap, keyword::node(void*))heap_free
    null(Value*) return
} (node NodeControl*, ctx GenContext*, fbuf FileBuffer*) visit_NodeControl Value*

{
    ((false)iota)itoa = forStart byte*
    ((false)iota)itoa = forLoop  byte*
    ((false)iota)itoa = forCond  byte*
    ((false)iota)itoa = forEnd   byte*

    null = _ void*
    [table::(scope::node(NodeRoot*)), forEnd, forLoop, null(byte*), strbuf::ctx] = _ctx GenContext
    (on_entry::node, true, &_ctx, fbuf)visit(void*) = _
    (_(Value*))destroy

    null(byte*) = str3 byte*; forStart = str2 byte*; forCond = str1 byte*
    (fbuf, "jmp L%\nL%:\n", &str1, 2)write_file_bufferf

    (scope::node, true, &_ctx, fbuf)visit(void*)

    (fbuf, "L%:\n", &forLoop, 1)write_file_bufferf

    (on_loop::node, true, &_ctx, fbuf)visit(void*) = _
    (_(Value*))destroy

    (fbuf, "L%:\n", &forCond, 1)write_file_bufferf

    (condition::node, true, &_ctx, fbuf)visit = condition Value*

    forEnd = str3; forStart = str2; (condition)value_to_str = str1

    { 
        (RAX, QWORD)create_reg(Value*) = reg Value*
        (reg, condition, fbuf)move
        (heap, str1(void*))heap_free
        (reg)value_to_str = str1
        (reg)destroy 
    } (type::condition == IMMVALUE) if

    (fbuf, "cmp %,0\njne L%\nL%:\n", &str1, 3)write_file_bufferf

    (condition)destroy
    (heap, str1(void*))heap_free
    (heap, forStart(void*))heap_free
    (heap, forLoop(void*))heap_free
    (heap, forCond(void*))heap_free
    (heap, forEnd(void*))heap_free
    null(Value*) return
} (node NodeFor*, ctx GenContext*, fbuf FileBuffer*) visit_NodeFor Value*

{   
    ((false)iota)itoa = whileStart byte*
    ((false)iota)itoa = whileCond  byte*
    ((false)iota)itoa = whileEnd   byte*

    (fbuf, "jmp L%\nL%:\n", &whileCond, 2)write_file_bufferf

    [table::(scope::node(NodeRoot*)), whileEnd, whileCond, null(byte*), strbuf::ctx] = _ctx GenContext
    (scope::node, true, &_ctx, fbuf)visit
    (fbuf, "L%:\n", &whileCond, 1)write_file_bufferf

    (condition::node, true, &_ctx, fbuf)visit = condition Value*
    whileEnd = str3 byte*; whileStart = str2 byte*; (condition)value_to_str = str1 byte*

    { 
        (RAX, QWORD)create_reg(Value*) = reg Value*
        (reg, condition, fbuf)move
        (heap, str1(void*))heap_free
        (reg)value_to_str = str1
        (reg)destroy 
    } (type::condition == IMMVALUE) if

    (fbuf, "cmp %,0\njne L%\nL%:\n", &str1, 3)write_file_bufferf

    (condition)destroy
    (heap, str1(void*))heap_free
    (heap, whileStart(void*))heap_free
    (heap, whileCond(void*))heap_free
    (heap, whileEnd(void*))heap_free
    null(Value*) return
} (node NodeWhile*, ctx GenContext*, fbuf FileBuffer*)visit_NodeWhile Value*

{
    (condition::node, true, ctx, fbuf)visit = condition Value*

    null(byte*) = ifEnd byte*
    {
        ((false)iota)itoa = ifEnd 
    } else
    {
        ifEndlbl::ctx = ifEnd
    } (ifEndlbl::ctx != null) if


    ((false)iota)itoa = ifNext byte*
    (condition)value_to_str = conditionStr byte*

    [table::(scope::node(NodeRoot*)), breaklbl::ctx, continuelbl::ctx, ifEnd, strbuf::ctx] = _ctx GenContext

    { 
        (RAX, QWORD)create_reg(Value*) = reg Value*
        (reg, condition, fbuf)move
        (heap, conditionStr(void*))heap_free
        (reg)value_to_str = conditionStr
        (reg)destroy 
    } (type::condition == IMMVALUE) if

    (fbuf, "cmp %,0\n", &conditionStr, 1)write_file_bufferf

    {
        (fbuf, "je L%\n", &ifEnd, 1)write_file_bufferf
        (scope::node, true, &_ctx, fbuf)visit
    } else
    {
        (fbuf, "je L%\n", &ifNext, 1)write_file_bufferf
        (scope::node, true, &_ctx, fbuf)visit
        (fbuf, "jmp L%\n", &ifEnd, 1)write_file_bufferf
        (fbuf, "L%:\n", &ifNext, 1)write_file_bufferf

        [table::ctx, breaklbl::ctx, continuelbl::ctx, ifEnd, strbuf::ctx] = _ctx
        (_else::node, true, &_ctx, fbuf)visit
    } (_else::node != null) if

    {
        (fbuf, "L%:\n", &ifEnd, 1)write_file_bufferf
        (heap, ifEnd(void*))heap_free
    } (ifEndlbl::ctx == null) if

    (heap, conditionStr(void*))heap_free
    (heap, ifNext(void*))heap_free
    (condition)destroy
    null(Value*) return
} (node NodeIf*, ctx GenContext*, fbuf FileBuffer*) visit_NodeIf Value*

{
    (table::ctx, name::node)get_var_pos = pos Mempos*
    (heap, name::node(void*))heap_free
    pos(Value*) return
} (node NodeVar*, ctx GenContext*, fbuf FileBuffer*) visit_NodeVar Value*

{
    (val::node, true, ctx, fbuf)visit = val Value*
    (table::ctx, name::node)get_var_pos = pos Mempos*
    (pos(Value*), val, fbuf)move
    (heap, name::node(void*))heap_free
    (val)destroy
    pos(Value*) return
} (node NodeVarAssign*, ctx GenContext*, fbuf FileBuffer*) visit_NodeVarAssign Value*

{
    (val::node, true, ctx, fbuf)visit = val Value*

    (table::ctx, name::node, false)get_symbol(Var*) = var Var*
    true = assigned::var

    (table::ctx, name::node)get_var_pos = pos Mempos*
    (pos(Value*), val, fbuf)move

    (val)destroy
    pos(Value*) return
} (node NodeVarDef*, ctx GenContext*, fbuf FileBuffer*) visit_NodeVarDef Value*

{
    (node::node, true, ctx, fbuf)visit = value Value*
    null(Reg*) = reg Reg*

    {
        value(ImmValue*) = immvalue ImmValue*
        -val::immvalue = val::immvalue
        value return
    } (type::value == IMMVALUE && op::node == TT_MIN) if

    {
        (RDI, QWORD)create_reg = reg
        (reg(Value*), value, fbuf)move
        (value)destroy
        (reg::reg, size::(type::node(Type*)), 0)create_mempos(Value*) = value
        (reg(Value*))destroy
        value return
    } (op::node == TT_STAR) if

    RAX = _reg short
    { RDI = _reg } (!lhs) if

    QWORD = reg_size short
    {size::(value(Mempos*)) = reg_size} (type::value == MEMPOS && op::node != TT_AND) if

    (_reg, reg_size)create_reg = reg
    (op::node, value, reg, fbuf)unary_instr = res Value*
    { (reg(Value*))destroy } (reg != res) if
    { (value)destroy } (value != res) if
    res return
} (node NodeUnop*, lhs byte, ctx GenContext*, fbuf FileBuffer*) visit_NodeUnop Value*

{
    null(Value*) = left Value*
    null(Value*) = right Value*
    {
        (left::node, true, ctx, fbuf)visit  = left
        (right::node, false, ctx, fbuf)visit = right
        val::(left(ImmValue*)) = leftValue long
        val::(right(ImmValue*)) = rightValue long
        (left(ImmValue*), right(ImmValue*), op::node)calculate_binexpr
        (heap, right(void*))heap_free
        IMMVALUE = type::left
        left return
    } ((node(Node*))returns_immValue) if

    (left::node, true, ctx, fbuf)visit = left

    QWORD = regSize short
    {
        left(Mempos*) = mempos Mempos*
        size::mempos = regSize
    } (type::left == MEMPOS) if

    null(Reg*) = reg Reg*
    { (RDI, regSize)create_reg = reg } else
    { (RAX, regSize)create_reg = reg } (lhs) if

    { 
        (R10, QWORD)create_reg = new_reg Reg*
        (new_reg(Value*), reg(Value*), fbuf)move(Reg*)
        (reg(Value*))destroy
        new_reg = reg
        {
            (left)destroy
            reg(Value*) = left
        } (type::left == REG) if
    } ((right::node, false, reg)uses_reg) if

    reg = _reg Reg*
    (right::node, false, ctx, fbuf)visit = right
    (op::node, left, right, reg, fbuf)bin_instr(Reg*) = reg

    { (left)destroy } (left != reg) if
    (right)destroy
    reg(Value*) return
} (node NodeBinop*, lhs byte, ctx GenContext*, fbuf FileBuffer*) visit_NodeBinop Value*

{
    (val::node)create_immvalue(Value*) return
} (node NodeIntLit*, ctx GenContext*, fbuf FileBuffer*) visit_NodeIntLit Value*

{
    "mov" = instr byte*

    dest = _dest Value*
    src = _src Value*
    null(Mempos*) = destMempos Mempos* 
    null(Mempos*) = srcMempos Mempos* 
    null(Reg*) = destReg Reg*
    null(Reg*) = srcReg Reg*

    { 
        dest(Reg*) = destReg
        src(Reg*) = srcReg
        { dest return } (reg::destReg == reg::srcReg && size::destReg >= size::srcReg) if
        {
            (reg::srcReg, size::destReg)create_reg(Value*) = src
        } (size::destReg > size::srcReg) if
    }  ((type::dest == REG && type::src == REG)) if

    {
        dest(Mempos*) = destMempos
        src(Mempos*) = srcMempos
        (RAX, size::srcMempos)create_reg(Value*) = r Value*
        (r, src, fbuf)move = src
    } (type::dest == MEMPOS && type::src == MEMPOS) if
    
    {
        (RCX, QWORD)create_reg = rcx Reg*
        (rcx(Value*), src, fbuf)move = src
    } (type::dest == MEMPOS && type::src == IMMVALUE && (val::(src(ImmValue*)) & -4294967296) != 0) if

    {
        dest(Mempos*) = destMempos
        src(Reg*) = srcReg
        {
            (reg::srcReg, size::destMempos)create_reg(Value*) = src
        } (size::destMempos > size::srcReg) if

        {
            (reg::srcReg, size::destMempos)create_reg(Value*) = src
            (src, _src, fbuf)move
        } (size::destMempos < size::srcReg) if
    } (type::dest == MEMPOS && type::src == REG) if

    {
        dest(Reg*) = destReg
        src(Mempos*) = srcMempos

        {
            (reg::destReg, size::srcMempos)create_reg(Value*) = dest
        } (size::destReg > size::srcMempos) if
    } (type::dest == REG && type::src == MEMPOS) if

    {
        dest(Reg*) = destReg
        src(Reg*) = srcReg
        {
            "movsx" = instr
        } (size::destReg < size::srcReg) if

        {
            "movsxd" = instr
        } (size::destReg == QWORD && size::srcReg == DWORD) if
    } ((type::dest == REG) && (type::src == REG || type::src == MEMPOS)) if

    (src)value_to_str = str3 byte*; (dest)value_to_str = str2 byte*; instr = str1 byte*
    (fbuf, "% %,%\n", &str1, 3)write_file_bufferf
    { (heap, dest(void*))heap_free } (_dest != dest) if
    { (heap,  src(void*))heap_free } (_src  != src)  if
    (heap, str2(void*))heap_free
    (heap, str3(void*))heap_free
    _dest return
} (dest Value*, src Value*, fbuf FileBuffer*) move Value*

{
    arg = operand Value*
    {
        (reg::(arg(Reg*)), QWORD)create_reg(Value*) = operand
        (operand, arg, fbuf)move
    } (type::arg == REG && size::(arg(Reg*)) != QWORD) if else
    {
        (reg::(arg(Mempos*)), QWORD)create_reg(Value*) = operand
        (operand, arg, fbuf)move
        (heap, operand(void*))heap_free
        (reg::(arg(Mempos*)), QWORD, offset::(arg(Mempos*)))create_mempos(Value*) = operand
    } (type::arg == MEMPOS && size::(arg(Mempos*)) != QWORD) if

    (operand)value_to_str = operandStr byte*
    (fbuf, "push %\n", &operandStr, 1)write_file_bufferf
    (heap, operandStr(void*))heap_free
    { (heap, operand(void*))heap_free } (operand != arg) if
    return
} (arg Value*, fbuf FileBuffer*)push void

{
    null(byte*) = str2 byte*; null(byte*) = str1 byte*
    {
        (arg)value_to_str = str2; (reg(Value*))value_to_str = str1
        (fbuf, "lea %, %\n", &str1, 2)write_file_bufferf
        (heap, str2(void*))heap_free
        (heap, str1(void*))heap_free
        reg(Value*) return
    } (_instr == TT_AND) if

    { 
        (reg(Value*), arg, fbuf)move
        reg(Value*) = arg
    } (type::arg != REG) if
    null(byte*) = instr byte*

    { "neg" = instr} (_instr == TT_MIN) if

    (arg)value_to_str = str2; instr = str1
    (fbuf, "% %\n", &str1, 2)write_file_bufferf
    (heap, str2(void*))heap_free
    arg return
} (_instr short, arg Value*, reg Reg*, fbuf FileBuffer*) unary_instr Value*

{
    arg2 = _arg2 Value*
    { 
        (reg(Value*), arg1, fbuf)move
        reg(Value*) = arg1
    } (type::arg1 != REG) if
    null(byte*) = instr byte*

    {
        (RCX, QWORD)create_reg = rcx Reg*
        (rcx(Value*), arg2, fbuf)move = arg2
    } (type::arg2 == IMMVALUE && (val::(arg2(ImmValue*)) & -4294967296) != 0) if

    {
        arg2(Mempos*) = mempos Mempos*
        {
            (RCX, size::(arg1(Reg*)))create_reg(Value*) = arg2
            (arg2, mempos(Value*), fbuf)move
        } (size::mempos != size::(arg1(Reg*))) if
    } (type::arg2 == MEMPOS) if

    {
        (RDI, size::(arg1(Reg*)))create_reg = divisor Reg*
        (divisor(Value*), arg2, fbuf)move
        
        (RAX, size::(arg1(Reg*)))create_reg = dividend Reg*
        (dividend(Value*), arg1, fbuf)move(Value*) = arg1

        (fbuf, "cqo\n")write_file_buffer
        (divisor(Value*))value_to_str = divisorStr byte*
        (fbuf, "idiv %\n", &divisorStr, 1)write_file_bufferf
        (heap, divisorStr(void*))heap_free
        (divisor(Value*))destroy

        { 
            (RDX, size::dividend)create_reg = r Reg*
            (dividend(Value*))destroy
            r(Value*) return
        } (_instr == TT_PERCENT) if
        arg1 return
    } (_instr == TT_FSLASH || _instr == TT_PERCENT) if

    null(byte*) = str3 byte*; null(byte*) = str2 byte*; null(byte*) = str1 byte*
    
    {
        { "setge" = instr } (_instr == TT_GTE)  if else
        { "setg"  = instr } (_instr == TT_GTH)  if else
        { "setl"  = instr } (_instr == TT_LTE)  if else
        { "setle" = instr } (_instr == TT_LTH)  if else
        { "sete"  = instr } (_instr == TT_IS)   if else
        { "setne" = instr } (_instr == TT_ISNT) if 

        (arg2)value_to_str = str2; (arg1)value_to_str = str1
        (fbuf, "cmp %,%\n", &str1, 2)write_file_bufferf
        (reg::reg, BYTE)create_reg(Value*) = arg1
        (reg(Value*))destroy

        (arg1)value_to_str = str2; instr = str1
        (fbuf, "% %\n", &str1, 2)write_file_bufferf
        (heap, str2(void*))heap_free
        arg1 return
    } (_instr == TT_GTE || _instr == TT_GTH || _instr == TT_LTE || _instr == TT_LTH || _instr == TT_IS || _instr == TT_ISNT) if

    { "and"  = instr } (_instr == TT_AND)  if else
    { "or"   = instr } (_instr == TT_OR)   if else
    { "xor"  = instr } (_instr == TT_XOR)  if else
    { "shl"  = instr } (_instr == TT_SHL)  if else
    { "sar"  = instr } (_instr == TT_SHR)  if else
    { "sub"  = instr } (_instr == TT_MIN)  if else
    { "imul" = instr } (_instr == TT_STAR) if else
    { "add"  = instr } (_instr == TT_PLUS) if

    (arg2)value_to_str = str3; (arg1)value_to_str = str2; instr = str1
    (fbuf, "% %,%\n", &str1, 3)write_file_bufferf
    { (heap, arg2(void*))heap_free } (arg2 != _arg2) if
    { (heap, reg(void*))heap_free } (arg1 != reg) if
    (heap, str2(void*))heap_free    
    (heap, str3(void*))heap_free
    arg1 return
} (_instr short, arg1 Value*, arg2 Value*, reg Reg*, fbuf FileBuffer*) bin_instr Value*

#####################################################################
# other
#####################################################################

FileBuffer {
    fd    int
    buf   byte*
    cap   long
    count long
} struct

# returns 1 when file cannot be opened
# returns 2 when the buffer cant be allocated
{
    (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, O_WRONLY | O_CREAT | O_TRUNC, filename)open = fd int
    { 1 return } (fd < 0) if

    fd = fd::fb
    0 = count::fb
    (heap, bufsize)heap_alloc = buf byte*

    { 2 return } (buf == null) if

    bufsize = cap::fb
    buf = buf::fb
    0 return
} (fb FileBuffer*, filename byte*, bufsize long) open_file_buffer int

{
    (fb)flush_file_buffer
    (fd::fb)close
    (heap, buf::fb(void*))heap_free
    0 = cap::fb
    return
} (fb FileBuffer*) close_file_buffer void

{
    (count::fb, buf::fb, fd::fb)write
    0 = count::fb
    return
} (fb FileBuffer*) flush_file_buffer void

{
    (buf)strlen = buflen long
    { (fbuf)flush_file_buffer } (buflen + count::fbuf > cap::fbuf) if
    (buf(void*), buf::fbuf + count::fbuf, buflen)memcpy
    count::fbuf + buflen = count::fbuf
    return
} (fbuf FileBuffer*, buf byte*) write_file_buffer void

{
    (template, argv, argc)strformat = str byte*
    (fbuf, str)write_file_buffer
    (heap, str(void*))heap_free
    return
} (fbuf FileBuffer*, template byte*, argv byte**, argc int) write_file_bufferf void

{
    0 = argc long
    # argc is stored at [rsp + 24]
    # this is because the variable argc takes up 8 bytes
    # rbp gets pushed onto the stack at the start of a function taking up 8 bytes
    # and the return adress get pushed onto the stack when calling the function also taking up 8 bytes
    asm("mov rax, [rsp + 24]")
    asm("mov [rbp - 8], rax")
    argc return
} () get_argc long

{
    0(byte**) = argv byte**
    # the pointer to the first argument is stored at [rsp + 32]
    # because argc is stored at [rsp + 24], and takes up 8 bytes
    # see explanation in get_argc
    asm("lea rax, [rsp + 32]")
    asm("mov [rbp - 8], rax")
    argv return
} () get_argv byte**

{
    [0] = statbuf stat
    (&statbuf, fd)fstat
    st_size::statbuf = size long
    (heap, size+1)heap_alloc(byte*) = buf byte*
    (size, buf, fd)read 
    0 = *(buf + size + 1)
    buf return
} (fd int) read_file byte*

{
    STDOUT = fd int
    { STDERR = fd } (log_level == LOG_ERROR) if
    { (fd, "[ERROR] ")fprint } (log_level == LOG_ERROR) if else
    { (fd, "[WARN] ")fprint  } (log_level == LOG_WARN)  if else
    { (fd, "[INFO] ")fprint  } (log_level == LOG_INFO)  if
    (fd, str)fprint
    return
} (log_level int, str byte*)log void

{
    (format, argv, argc)strformat = str byte*
    (str)print
    (heap, str(void*))heap_free
    return
} (format byte*, argv byte**, argc int) printf void


{
    (str)strlen = len long
    (len, str, 1)write
    return
} (str byte*) print void

{
    (str)strlen = len long
    (len, str, fd)write
    return
} (fd int, str byte*) fprint void

{
    (num)itoa = str byte*
    (str)print
    (heap, str(void*))heap_free
    return
} (num long) print_num void

{
    (num)itoa = str byte*
    (fd, str)fprint
    (heap, str(void*))heap_free
    return
} (fd int, num long) fprint_num void

{
    false = is_neg byte
    { -num = num; true = is_neg } (num < 0) if
    (num)log10l = log10 long
    (num >= (10, log10)pow) || num < 8 = x long
    log10 + x + is_neg = length long

    (heap, length + 1)heap_alloc(byte*) = str byte*
    0 = *(str + length)

    {
        num % 10 = digit byte
        num / 10 = num

        digit + '0' = digit
        digit = *(str + i)
    } (i - 1 = i; i >= 0; length-1 = i long) for

    {'-' = *str } (is_neg) if
    str return
} (num long) itoa byte*

{   
    0 = len long
    { len + 1 = len } (*(str + len)) while
    len return
} (str byte*) strlen long

{
    (str1)strlen = str1len long
    (str2)strlen = str2len long
    { false return } (str1len != str2len) if
    true = is_equal byte

    {
        (*(str1 + i) == *(str2 + i)) = is_equal
        { break } (!is_equal) if
    } (i + 1 = i; i < str1len; 0 = i int) for

    is_equal return
} (str1 byte*, str2 byte*) strcmp byte

{
    (str1)strlen = str1len long
    (str2)strlen = str2len long
    (heap, str1len + str2len + 1)heap_alloc = str byte*

    0 = i int
    { *(str1 + i) = *(str + i) }         (i + 1 = i; i < str1len;i)         for
    { *(str2 + i-str1len) = *(str + i) } (i + 1 = i; i < str1len+str2len;i) for
    0 = *(str + i)
    str return
} (str1 byte*, str2 byte*) strconcat byte*

{
    (template)strlen = template_len long
    template_len - argc = len long
    0 = i int
    {
        (argv + i * @void*) = arg byte**
        (*arg)strlen + len = len
    } (i + 1 = i; i < argc; i) for
    
    (heap, len+1)heap_alloc(byte*) = buf byte*
    
    0 = j int
    0 = argindex int
    {
        *(template + i) = c byte
        
        {
            (argv + argindex * @void*) = arg 
            *arg = str byte*
            (str)strlen = N int
            {
                *(str + n) = *(buf + j)
                j + 1 = j
            } (n + 1 = n; n < N; 0 = n int) for
            argindex + 1 = argindex
            continue
        } (c == '%' && argindex < argc) if

        c = *(buf + j)
        j + 1 = j
    } (i + 1 = i; i < template_len; 0 = i) for
    0 = *(buf + len)
    buf return
} (template byte*, argv byte**, argc int) strformat byte*

{
    (src)strlen = len long
    
    {
        *(src + i) = x byte
        x = *(dest + i)
        { break } (!x) if
    } (i + 1 = i; true; 0 = i long) for  
    return
} (src byte*, dest byte*) strcpy void

{
    0 = i long
    count % 8 = n long

    {
        *(src(long*) + i) = *(dest(long*) + i)
    } (i + 8 = i; i < count-n && count >= 8; i) for

    { *(src(int*)   + i) = *(dest(int*)   + i); n - 4 = n; i + 4 = i } (n >= 4) if
    { *(src(short*) + i) = *(dest(short*) + i); n - 2 = n; i + 2 = i } (n >= 2) if
    { *(src(byte*)  + i) = *(dest(byte*)  + i); n - 1 = n; i + 1 = i } (n >= 1) if

    return
} (src void*, dest void*, count long) memcpy void

{
    {
        val = *((dest + i)(byte*))
    } (i + 1 = i; i < count; 0 = i long) for

    return
} (dest void*, val byte, count long) memset void

{
    (str)strlen = len long
    0 = *res

    {
        *res * 10 = *res
        *(str + i) = n long
        { break } (n == 0) if
        { 1 return } (n > '9' || n < '0') if

        n - '0' = n
        n + *res = *res
    } (i + 1 = i; i < len; 0 = i int) for

    0 return
} (str byte*, res long*) try_parse_int byte

{
    0 = y int 
    64 = n int
    x >> 32 = y; {n - 32 = n; y = x } (y != 0) if
    x >> 16 = y; {n - 16 = n; y = x } (y != 0) if
    x >> 8 = y; { n - 8 = n; y = x } (y != 0) if
    x >> 4 = y; { n - 4 = n; y = x } (y != 0) if
    x >> 2 = y; { n - 2 = n; y = x } (y != 0) if
    x >> 1 = y; { n - 2 return } (y != 0) if
    n - x return
} (x long) clzl long

{
    { 0 return } (x == 0) if
    63 - (x)clzl return
} (x long) log2l long

{
    (x)log2l / (10)log2l return
} (x long) log10l long

{
    x = n int
    { n * x = n } (i + 1 = i; i < pow; 1 = i int) for
    n return
} (x long, pow long) pow long

{
    _iota = n long
    { _iota + 1 = _iota } else { 0 = _iota } (reset) if
    n return
} (reset byte) iota long

#####################################################################
# syscalls
#####################################################################
stat {
    st_dev        long
    st_ino        long
    st_nlink      long
    st_mode       int
    st_uid        int
    st_gid        int
    __pad0        int
    st_rdev       long
    st_size       long
    st_blksize    long
    st_blocks     long
    st_atime      long
    st_atime_nsec long
    st_mtime      long
    st_mtime_nsec long
    st_ctime      long
    st_ctime_nsec long
    __unused1     long
    __unused2     long
    __unused3     long
} struct

{
    asm("mov rax, 0")
    asm("syscall")
    return
} (count long, buf byte*, fd int) read void

{
    asm("mov rax, 1")
    asm("syscall")
    return
} (count long, buf byte*, fd int) write void

{
    -1 = fd int
    asm("mov rax, 2")
    asm("syscall")
    asm("mov [rbp - 24], eax")
    fd return
} (mode long, flags int, fn byte*) open int

{
    asm("mov rax, 3")
    asm("syscall")
    return
} (fd int) close void

{
    asm("mov rax, 5")
    asm("syscall")
    return
} (statbuf stat*, fd int) fstat void

{   
    null = mem void* 
    asm("mov r10, rcx")
    asm("mov rax, 9")
    asm("syscall")
    asm("mov [rbp - 44], rax")
    mem return
} (offset long, fd int, flags int, prot int, len long, addr void*) mmap void*

{
    asm("mov rax, 60")
    asm("syscall")
    return
} (code long) exit void

#####################################################################
# malloc
#####################################################################

heapchunk_t {
    size long
    start void*
    inuse byte
} struct

heapinfo_t {
    chunks heapchunk_t*
    nchunks long
    chunks_cap long
    memory void*
} struct

{
    nchunks::heap = nchunks long

    ("========================================================================\n")print
    {
        (chunks::heap + i * @heapchunk_t) = Pchunk heapchunk_t*
        ("[")print; (i)print_num; ("] ")print
        ("start: ")print; (start::Pchunk(long))print_num
        (", ")print; ("size: ")print; (size::Pchunk)print_num
        (", ")print; ("inuse: ")print
        { ("false")print } else { ("true")print } (inuse::Pchunk) if
        ("\n")print

    } (i + 1 = i; i < nchunks; 0 = i int) for
    ("========================================================================\n")print

    return
} (heap heapinfo_t*) display_heap void

{       
    { 1 return } (size < 1024) if

    (0, -1, MAP_PRIVATE | MAP_ANONYMOUS, PROT_READ | PROT_WRITE, size, null) mmap = memory_start void*
    (0, -1, MAP_PRIVATE | MAP_ANONYMOUS, PROT_READ | PROT_WRITE, size, null) mmap(heapchunk_t*) = chunk_memory heapchunk_t*
    { 1 return } (memory_start < null) if
    { 1 return } (chunk_memory < null) if

    [size, memory_start, false] = chunk heapchunk_t

    chunk_memory = chunks::heap
    size / @heapchunk_t = chunks_cap::heap
    1 = nchunks::heap
    
    chunk = *(chunks::heap)

    0 return
} (heap heapinfo_t*, size long) init_heap int

{
    { 1 return } ( nchunks::heap + 1 == chunks_cap::heap) if

    {
        (chunks::heap + i * @heapchunk_t) = Pchunk heapchunk_t*
        *Pchunk = _chunk heapchunk_t
        (chunks::heap + (i + 1) * @heapchunk_t) = Pchunk
        _chunk = *Pchunk
    } (i - 1 = i; i >= index; nchunks::heap - 1 = i int) for

    (chunks::heap + index * @heapchunk_t) = Pchunk
    *chunk = *Pchunk

    nchunks::heap + 1 = nchunks::heap
    0 return
} (heap heapinfo_t*, chunk heapchunk_t*, index long) insert_chunk int

{
    {
        nchunks::heap - 1 = nchunks::heap
        return
    } (index == nchunks::heap - 1) if

    {
        (chunks::heap + (i + 1) * @heapchunk_t) = Pchunk heapchunk_t*
        *Pchunk = _chunk heapchunk_t

        (chunks::heap + i * @heapchunk_t) = Pchunk
        _chunk = *Pchunk
    } (i + 1 = i; i < (nchunks::heap - 1); index = i int) for

    nchunks::heap - 1 = nchunks::heap
    return
} (heap heapinfo_t*, index long) remove_chunk void

{
    (chunks::heap + chunk_index * @heapchunk_t) = chunk heapchunk_t*

    nchunks::heap = new_chunk_index long
    [bytes, start::chunk, false] = new_chunk heapchunk_t

    start::chunk + bytes = start::chunk
    size::chunk - bytes = size::chunk

    {
        null(heapchunk_t*) return
    } ((heap, &new_chunk, chunk_index)insert_chunk) if

    chunk return
} (chunk_index long, heap heapinfo_t*, bytes long) split_chunk heapchunk_t*

{ 
    # nchunks::heap - 1 = chunk_index long
    0 = chunk_index long
    bytes+7&~7 = bytes

    {
        ((chunks::heap) + i * @heapchunk_t) = chunk heapchunk_t*

        { continue } (size::chunk < bytes) if
        { continue } (inuse::chunk) if

        { 
            (i, heap, bytes)split_chunk = chunk
        } (size::chunk > bytes) if

        true = inuse::chunk
        start::chunk return
    } (i + 1 = i; i < nchunks::heap; 0 = i int) for
    # } (i - 1 = i; i >= 0; chunk_index = i int) for

    null return
} (heap heapinfo_t*, bytes long) heap_alloc void*

{
    {
        ((chunks::heap) + i * @heapchunk_t) = chunk heapchunk_t*

        { 
            i return 
        } (start::chunk == ptr) if

    } (i + 1 = i; i < nchunks::heap; 0 = i int) for

    -1 return
} (heap heapinfo_t*, ptr void*) find_chunk long

{
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*

    {
        ((chunks::heap) + (index + 1) * @heapchunk_t) = Rchunk heapchunk_t*

        { 
            size::Rchunk + size::chunk = size::chunk
            (heap, index + 1)remove_chunk
        } ( !inuse::Rchunk ) if

    } (index < nchunks::heap - 1) if

    {
        ((chunks::heap) + (index - 1) * @heapchunk_t) = Lchunk heapchunk_t*

        { 
            start::Lchunk = start::chunk
            size::chunk + size::Lchunk = size::chunk
            (heap, index - 1)remove_chunk
        } ( !inuse::Lchunk ) if

    } (index > 0) if

    return
} (heap heapinfo_t*, index long) merge_chunk void

{
    (heap, ptr)find_chunk = index long
    { return } ( index == -1 ) if
    
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*

    { return } (!inuse::chunk) if

    false = inuse::chunk
    (heap, index)merge_chunk

    return
} (heap heapinfo_t*, ptr void*) heap_free void

{
    (heap, buf)find_chunk = index long
    ((chunks::heap) + index * @heapchunk_t) = chunk heapchunk_t*
    (heap, new_size)heap_alloc = new_buf void*

    size::chunk = size long
    { new_size = size } (size::chunk > new_size) if
    size % 8 = n long
    0 = i int

    {
        *(buf(long*) + i) = *(new_buf(long*) + i)
    } (i + 8 = i; i < size-n && size > 8; i) for

    n - i = n

    { *(buf(int*)   + i) = *(new_buf(int*)   + i); n - 4 = n; i + 4 = i } (n >= 4) if
    { *(buf(short*) + i) = *(new_buf(short*) + i); n - 2 = n; i + 2 = i } (n >= 2) if
    { *(buf(byte*)  + i) = *(new_buf(byte*)  + i); n - 1 = n; i + 1 = i } (n >= 1) if

    (heap, buf)heap_free
    new_buf return
} (heap heapinfo_t*, buf void*, new_size long) heap_realloc void*